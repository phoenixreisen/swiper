(function () {
    'use strict';

    /**
     * SSR Window 4.0.1
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2021, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: October 27, 2021
     */
    /* eslint-disable no-param-reassign */
    function isObject$1(obj) {
        return (obj !== null &&
            typeof obj === 'object' &&
            'constructor' in obj &&
            obj.constructor === Object);
    }
    function extend$1(target = {}, src = {}) {
        Object.keys(src).forEach((key) => {
            if (typeof target[key] === 'undefined')
                target[key] = src[key];
            else if (isObject$1(src[key]) &&
                isObject$1(target[key]) &&
                Object.keys(src[key]).length > 0) {
                extend$1(target[key], src[key]);
            }
        });
    }

    const ssrDocument = {
        body: {},
        addEventListener() { },
        removeEventListener() { },
        activeElement: {
            blur() { },
            nodeName: '',
        },
        querySelector() {
            return null;
        },
        querySelectorAll() {
            return [];
        },
        getElementById() {
            return null;
        },
        createEvent() {
            return {
                initEvent() { },
            };
        },
        createElement() {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute() { },
                getElementsByTagName() {
                    return [];
                },
            };
        },
        createElementNS() {
            return {};
        },
        importNode() {
            return null;
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: '',
        },
    };
    function getDocument() {
        const doc = typeof document !== 'undefined' ? document : {};
        extend$1(doc, ssrDocument);
        return doc;
    }

    const ssrWindow = {
        document: ssrDocument,
        navigator: {
            userAgent: '',
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: '',
        },
        history: {
            replaceState() { },
            pushState() { },
            go() { },
            back() { },
        },
        CustomEvent: function CustomEvent() {
            return this;
        },
        addEventListener() { },
        removeEventListener() { },
        getComputedStyle() {
            return {
                getPropertyValue() {
                    return '';
                },
            };
        },
        Image() { },
        Date() { },
        screen: {},
        setTimeout() { },
        clearTimeout() { },
        matchMedia() {
            return {};
        },
        requestAnimationFrame(callback) {
            if (typeof setTimeout === 'undefined') {
                callback();
                return null;
            }
            return setTimeout(callback, 0);
        },
        cancelAnimationFrame(id) {
            if (typeof setTimeout === 'undefined') {
                return;
            }
            clearTimeout(id);
        },
    };
    function getWindow() {
        const win = typeof window !== 'undefined' ? window : {};
        extend$1(win, ssrWindow);
        return win;
    }

    /**
     * Dom7 4.0.1
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * https://framework7.io/docs/dom7.html
     *
     * Copyright 2021, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: October 27, 2021
     */

    /* eslint-disable no-proto */
    function makeReactive(obj) {
      const proto = obj.__proto__;
      Object.defineProperty(obj, '__proto__', {
        get() {
          return proto;
        },

        set(value) {
          proto.__proto__ = value;
        }

      });
    }

    class Dom7 extends Array {
      constructor(items) {
        super(...(items || []));
        makeReactive(this);
      }

    }

    function arrayFlat(arr = []) {
      const res = [];
      arr.forEach(el => {
        if (Array.isArray(el)) {
          res.push(...arrayFlat(el));
        } else {
          res.push(el);
        }
      });
      return res;
    }
    function arrayFilter(arr, callback) {
      return Array.prototype.filter.call(arr, callback);
    }
    function arrayUnique(arr) {
      const uniqueArray = [];

      for (let i = 0; i < arr.length; i += 1) {
        if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
      }

      return uniqueArray;
    }

    // eslint-disable-next-line

    function qsa(selector, context) {
      if (typeof selector !== 'string') {
        return [selector];
      }

      const a = [];
      const res = context.querySelectorAll(selector);

      for (let i = 0; i < res.length; i += 1) {
        a.push(res[i]);
      }

      return a;
    }

    function $(selector, context) {
      const window = getWindow();
      const document = getDocument();
      let arr = [];

      if (!context && selector instanceof Dom7) {
        return selector;
      }

      if (!selector) {
        return new Dom7(arr);
      }

      if (typeof selector === 'string') {
        const html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          let toCreate = 'div';
          if (html.indexOf('<li') === 0) toCreate = 'ul';
          if (html.indexOf('<tr') === 0) toCreate = 'tbody';
          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
          if (html.indexOf('<tbody') === 0) toCreate = 'table';
          if (html.indexOf('<option') === 0) toCreate = 'select';
          const tempParent = document.createElement(toCreate);
          tempParent.innerHTML = html;

          for (let i = 0; i < tempParent.childNodes.length; i += 1) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          arr = qsa(selector.trim(), context || document);
        } // arr = qsa(selector, document);

      } else if (selector.nodeType || selector === window || selector === document) {
        arr.push(selector);
      } else if (Array.isArray(selector)) {
        if (selector instanceof Dom7) return selector;
        arr = selector;
      }

      return new Dom7(arrayUnique(arr));
    }

    $.fn = Dom7.prototype;

    // eslint-disable-next-line

    function addClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        el.classList.add(...classNames);
      });
      return this;
    }

    function removeClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        el.classList.remove(...classNames);
      });
      return this;
    }

    function toggleClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      this.forEach(el => {
        classNames.forEach(className => {
          el.classList.toggle(className);
        });
      });
    }

    function hasClass(...classes) {
      const classNames = arrayFlat(classes.map(c => c.split(' ')));
      return arrayFilter(this, el => {
        return classNames.filter(className => el.classList.contains(className)).length > 0;
      }).length > 0;
    }

    function attr(attrs, value) {
      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this[0]) return this[0].getAttribute(attrs);
        return undefined;
      } // Set attrs


      for (let i = 0; i < this.length; i += 1) {
        if (arguments.length === 2) {
          // String
          this[i].setAttribute(attrs, value);
        } else {
          // Object
          for (const attrName in attrs) {
            this[i][attrName] = attrs[attrName];
            this[i].setAttribute(attrName, attrs[attrName]);
          }
        }
      }

      return this;
    }

    function removeAttr(attr) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].removeAttribute(attr);
      }

      return this;
    }

    function transform(transform) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].style.transform = transform;
      }

      return this;
    }

    function transition$1(duration) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;
      }

      return this;
    }

    function on(...args) {
      let [eventType, targetSelector, listener, capture] = args;

      if (typeof args[1] === 'function') {
        [eventType, listener, capture] = args;
        targetSelector = undefined;
      }

      if (!capture) capture = false;

      function handleLiveEvent(e) {
        const target = e.target;
        if (!target) return;
        const eventData = e.target.dom7EventData || [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
          const parents = $(target).parents(); // eslint-disable-line

          for (let k = 0; k < parents.length; k += 1) {
            if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
          }
        }
      }

      function handleEvent(e) {
        const eventData = e && e.target ? e.target.dom7EventData || [] : [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        listener.apply(this, eventData);
      }

      const events = eventType.split(' ');
      let j;

      for (let i = 0; i < this.length; i += 1) {
        const el = this[i];

        if (!targetSelector) {
          for (j = 0; j < events.length; j += 1) {
            const event = events[j];
            if (!el.dom7Listeners) el.dom7Listeners = {};
            if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
            el.dom7Listeners[event].push({
              listener,
              proxyListener: handleEvent
            });
            el.addEventListener(event, handleEvent, capture);
          }
        } else {
          // Live events
          for (j = 0; j < events.length; j += 1) {
            const event = events[j];
            if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
            if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
            el.dom7LiveListeners[event].push({
              listener,
              proxyListener: handleLiveEvent
            });
            el.addEventListener(event, handleLiveEvent, capture);
          }
        }
      }

      return this;
    }

    function off(...args) {
      let [eventType, targetSelector, listener, capture] = args;

      if (typeof args[1] === 'function') {
        [eventType, listener, capture] = args;
        targetSelector = undefined;
      }

      if (!capture) capture = false;
      const events = eventType.split(' ');

      for (let i = 0; i < events.length; i += 1) {
        const event = events[i];

        for (let j = 0; j < this.length; j += 1) {
          const el = this[j];
          let handlers;

          if (!targetSelector && el.dom7Listeners) {
            handlers = el.dom7Listeners[event];
          } else if (targetSelector && el.dom7LiveListeners) {
            handlers = el.dom7LiveListeners[event];
          }

          if (handlers && handlers.length) {
            for (let k = handlers.length - 1; k >= 0; k -= 1) {
              const handler = handlers[k];

              if (listener && handler.listener === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (!listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              }
            }
          }
        }
      }

      return this;
    }

    function trigger(...args) {
      const window = getWindow();
      const events = args[0].split(' ');
      const eventData = args[1];

      for (let i = 0; i < events.length; i += 1) {
        const event = events[i];

        for (let j = 0; j < this.length; j += 1) {
          const el = this[j];

          if (window.CustomEvent) {
            const evt = new window.CustomEvent(event, {
              detail: eventData,
              bubbles: true,
              cancelable: true
            });
            el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
            el.dispatchEvent(evt);
            el.dom7EventData = [];
            delete el.dom7EventData;
          }
        }
      }

      return this;
    }

    function transitionEnd$1(callback) {
      const dom = this;

      function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off('transitionend', fireCallBack);
      }

      if (callback) {
        dom.on('transitionend', fireCallBack);
      }

      return this;
    }

    function outerWidth(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          const styles = this.styles();
          return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
        }

        return this[0].offsetWidth;
      }

      return null;
    }

    function outerHeight(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          const styles = this.styles();
          return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
        }

        return this[0].offsetHeight;
      }

      return null;
    }

    function offset() {
      if (this.length > 0) {
        const window = getWindow();
        const document = getDocument();
        const el = this[0];
        const box = el.getBoundingClientRect();
        const body = document.body;
        const clientTop = el.clientTop || body.clientTop || 0;
        const clientLeft = el.clientLeft || body.clientLeft || 0;
        const scrollTop = el === window ? window.scrollY : el.scrollTop;
        const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
        return {
          top: box.top + scrollTop - clientTop,
          left: box.left + scrollLeft - clientLeft
        };
      }

      return null;
    }

    function styles() {
      const window = getWindow();
      if (this[0]) return window.getComputedStyle(this[0], null);
      return {};
    }

    function css(props, value) {
      const window = getWindow();
      let i;

      if (arguments.length === 1) {
        if (typeof props === 'string') {
          // .css('width')
          if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
          // .css({ width: '100px' })
          for (i = 0; i < this.length; i += 1) {
            for (const prop in props) {
              this[i].style[prop] = props[prop];
            }
          }

          return this;
        }
      }

      if (arguments.length === 2 && typeof props === 'string') {
        // .css('width', '100px')
        for (i = 0; i < this.length; i += 1) {
          this[i].style[props] = value;
        }

        return this;
      }

      return this;
    }

    function each(callback) {
      if (!callback) return this;
      this.forEach((el, index) => {
        callback.apply(el, [el, index]);
      });
      return this;
    }

    function filter(callback) {
      const result = arrayFilter(this, callback);
      return $(result);
    }

    function html(html) {
      if (typeof html === 'undefined') {
        return this[0] ? this[0].innerHTML : null;
      }

      for (let i = 0; i < this.length; i += 1) {
        this[i].innerHTML = html;
      }

      return this;
    }

    function text(text) {
      if (typeof text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      }

      for (let i = 0; i < this.length; i += 1) {
        this[i].textContent = text;
      }

      return this;
    }

    function is(selector) {
      const window = getWindow();
      const document = getDocument();
      const el = this[0];
      let compareWith;
      let i;
      if (!el || typeof selector === 'undefined') return false;

      if (typeof selector === 'string') {
        if (el.matches) return el.matches(selector);
        if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
        if (el.msMatchesSelector) return el.msMatchesSelector(selector);
        compareWith = $(selector);

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      if (selector === document) {
        return el === document;
      }

      if (selector === window) {
        return el === window;
      }

      if (selector.nodeType || selector instanceof Dom7) {
        compareWith = selector.nodeType ? [selector] : selector;

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      return false;
    }

    function index() {
      let child = this[0];
      let i;

      if (child) {
        i = 0; // eslint-disable-next-line

        while ((child = child.previousSibling) !== null) {
          if (child.nodeType === 1) i += 1;
        }

        return i;
      }

      return undefined;
    }

    function eq(index) {
      if (typeof index === 'undefined') return this;
      const length = this.length;

      if (index > length - 1) {
        return $([]);
      }

      if (index < 0) {
        const returnIndex = length + index;
        if (returnIndex < 0) return $([]);
        return $([this[returnIndex]]);
      }

      return $([this[index]]);
    }

    function append(...els) {
      let newChild;
      const document = getDocument();

      for (let k = 0; k < els.length; k += 1) {
        newChild = els[k];

        for (let i = 0; i < this.length; i += 1) {
          if (typeof newChild === 'string') {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;

            while (tempDiv.firstChild) {
              this[i].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom7) {
            for (let j = 0; j < newChild.length; j += 1) {
              this[i].appendChild(newChild[j]);
            }
          } else {
            this[i].appendChild(newChild);
          }
        }
      }

      return this;
    }

    function prepend(newChild) {
      const document = getDocument();
      let i;
      let j;

      for (i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          }
        } else if (newChild instanceof Dom7) {
          for (j = 0; j < newChild.length; j += 1) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }

      return this;
    }

    function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
            return $([this[0].nextElementSibling]);
          }

          return $([]);
        }

        if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
        return $([]);
      }

      return $([]);
    }

    function nextAll(selector) {
      const nextEls = [];
      let el = this[0];
      if (!el) return $([]);

      while (el.nextElementSibling) {
        const next = el.nextElementSibling; // eslint-disable-line

        if (selector) {
          if ($(next).is(selector)) nextEls.push(next);
        } else nextEls.push(next);

        el = next;
      }

      return $(nextEls);
    }

    function prev(selector) {
      if (this.length > 0) {
        const el = this[0];

        if (selector) {
          if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
            return $([el.previousElementSibling]);
          }

          return $([]);
        }

        if (el.previousElementSibling) return $([el.previousElementSibling]);
        return $([]);
      }

      return $([]);
    }

    function prevAll(selector) {
      const prevEls = [];
      let el = this[0];
      if (!el) return $([]);

      while (el.previousElementSibling) {
        const prev = el.previousElementSibling; // eslint-disable-line

        if (selector) {
          if ($(prev).is(selector)) prevEls.push(prev);
        } else prevEls.push(prev);

        el = prev;
      }

      return $(prevEls);
    }

    function parent(selector) {
      const parents = []; // eslint-disable-line

      for (let i = 0; i < this.length; i += 1) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }

      return $(parents);
    }

    function parents(selector) {
      const parents = []; // eslint-disable-line

      for (let i = 0; i < this.length; i += 1) {
        let parent = this[i].parentNode; // eslint-disable-line

        while (parent) {
          if (selector) {
            if ($(parent).is(selector)) parents.push(parent);
          } else {
            parents.push(parent);
          }

          parent = parent.parentNode;
        }
      }

      return $(parents);
    }

    function closest(selector) {
      let closest = this; // eslint-disable-line

      if (typeof selector === 'undefined') {
        return $([]);
      }

      if (!closest.is(selector)) {
        closest = closest.parents(selector).eq(0);
      }

      return closest;
    }

    function find(selector) {
      const foundElements = [];

      for (let i = 0; i < this.length; i += 1) {
        const found = this[i].querySelectorAll(selector);

        for (let j = 0; j < found.length; j += 1) {
          foundElements.push(found[j]);
        }
      }

      return $(foundElements);
    }

    function children(selector) {
      const children = []; // eslint-disable-line

      for (let i = 0; i < this.length; i += 1) {
        const childNodes = this[i].children;

        for (let j = 0; j < childNodes.length; j += 1) {
          if (!selector || $(childNodes[j]).is(selector)) {
            children.push(childNodes[j]);
          }
        }
      }

      return $(children);
    }

    function remove() {
      for (let i = 0; i < this.length; i += 1) {
        if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
      }

      return this;
    }

    const Methods = {
      addClass,
      removeClass,
      hasClass,
      toggleClass,
      attr,
      removeAttr,
      transform,
      transition: transition$1,
      on,
      off,
      trigger,
      transitionEnd: transitionEnd$1,
      outerWidth,
      outerHeight,
      styles,
      offset,
      css,
      each,
      html,
      text,
      is,
      index,
      eq,
      append,
      prepend,
      next,
      nextAll,
      prev,
      prevAll,
      parent,
      parents,
      closest,
      find,
      children,
      filter,
      remove
    };
    Object.keys(Methods).forEach(methodName => {
      Object.defineProperty($.fn, methodName, {
        value: Methods[methodName],
        writable: true
      });
    });

    function deleteProps(obj) {
      const object = obj;
      Object.keys(object).forEach(key => {
        try {
          object[key] = null;
        } catch (e) {// no getter for object
        }

        try {
          delete object[key];
        } catch (e) {// something got wrong
        }
      });
    }

    function nextTick(callback, delay = 0) {
      return setTimeout(callback, delay);
    }

    function now() {
      return Date.now();
    }

    function getComputedStyle$1(el) {
      const window = getWindow();
      let style;

      if (window.getComputedStyle) {
        style = window.getComputedStyle(el, null);
      }

      if (!style && el.currentStyle) {
        style = el.currentStyle;
      }

      if (!style) {
        style = el.style;
      }

      return style;
    }

    function getTranslate(el, axis = 'x') {
      const window = getWindow();
      let matrix;
      let curTransform;
      let transformMatrix;
      const curStyle = getComputedStyle$1(el);

      if (window.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;

        if (curTransform.split(',').length > 6) {
          curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
        } // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case


        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }

      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
        else curTransform = parseFloat(matrix[4]);
      }

      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
        else curTransform = parseFloat(matrix[5]);
      }

      return curTransform || 0;
    }

    function isObject(o) {
      return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
    }

    function isNode(node) {
      // eslint-disable-next-line
      if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
        return node instanceof HTMLElement;
      }

      return node && (node.nodeType === 1 || node.nodeType === 11);
    }

    function extend(...args) {
      const to = Object(args[0]);
      const noExtend = ['__proto__', 'constructor', 'prototype'];

      for (let i = 1; i < args.length; i += 1) {
        const nextSource = args[i];

        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
          const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);

          for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            const nextKey = keysArray[nextIndex];
            const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend(to[nextKey], nextSource[nextKey]);
                }
              } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                to[nextKey] = {};

                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend(to[nextKey], nextSource[nextKey]);
                }
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }

      return to;
    }

    function setCSSProperty(el, varName, varValue) {
      el.style.setProperty(varName, varValue);
    }

    function animateCSSModeScroll({
      swiper,
      targetPosition,
      side
    }) {
      const window = getWindow();
      const startPosition = -swiper.translate;
      let startTime = null;
      let time;
      const duration = swiper.params.speed;
      swiper.wrapperEl.style.scrollSnapType = 'none';
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      const dir = targetPosition > startPosition ? 'next' : 'prev';

      const isOutOfBound = (current, target) => {
        return dir === 'next' && current >= target || dir === 'prev' && current <= target;
      };

      const animate = () => {
        time = new Date().getTime();

        if (startTime === null) {
          startTime = time;
        }

        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);

        if (isOutOfBound(currentPosition, targetPosition)) {
          currentPosition = targetPosition;
        }

        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });

        if (isOutOfBound(currentPosition, targetPosition)) {
          swiper.wrapperEl.style.overflow = 'hidden';
          swiper.wrapperEl.style.scrollSnapType = '';
          setTimeout(() => {
            swiper.wrapperEl.style.overflow = '';
            swiper.wrapperEl.scrollTo({
              [side]: currentPosition
            });
          });
          window.cancelAnimationFrame(swiper.cssModeFrameID);
          return;
        }

        swiper.cssModeFrameID = window.requestAnimationFrame(animate);
      };

      animate();
    }

    let support;

    function calcSupport() {
      const window = getWindow();
      const document = getDocument();
      return {
        smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,
        touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
        passiveListener: function checkPassiveListener() {
          let supportsPassive = false;

          try {
            const opts = Object.defineProperty({}, 'passive', {
              // eslint-disable-next-line
              get() {
                supportsPassive = true;
              }

            });
            window.addEventListener('testPassiveListener', null, opts);
          } catch (e) {// No support
          }

          return supportsPassive;
        }(),
        gestures: function checkGestures() {
          return 'ongesturestart' in window;
        }()
      };
    }

    function getSupport() {
      if (!support) {
        support = calcSupport();
      }

      return support;
    }

    let deviceCached;

    function calcDevice({
      userAgent
    } = {}) {
      const support = getSupport();
      const window = getWindow();
      const platform = window.navigator.platform;
      const ua = userAgent || window.navigator.userAgent;
      const device = {
        ios: false,
        android: false
      };
      const screenWidth = window.screen.width;
      const screenHeight = window.screen.height;
      const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

      let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
      const windows = platform === 'Win32';
      let macos = platform === 'MacIntel'; // iPadOs 13 fix

      const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

      if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [0, 1, '13_0_0'];
        macos = false;
      } // Android


      if (android && !windows) {
        device.os = 'android';
        device.android = true;
      }

      if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
      } // Export object


      return device;
    }

    function getDevice(overrides = {}) {
      if (!deviceCached) {
        deviceCached = calcDevice(overrides);
      }

      return deviceCached;
    }

    let browser;

    function calcBrowser() {
      const window = getWindow();

      function isSafari() {
        const ua = window.navigator.userAgent.toLowerCase();
        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
      }

      return {
        isSafari: isSafari(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
      };
    }

    function getBrowser() {
      if (!browser) {
        browser = calcBrowser();
      }

      return browser;
    }

    function Resize({
      swiper,
      on,
      emit
    }) {
      const window = getWindow();
      let observer = null;

      const resizeHandler = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit('beforeResize');
        emit('resize');
      };

      const createObserver = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        observer = new ResizeObserver(entries => {
          const {
            width,
            height
          } = swiper;
          let newWidth = width;
          let newHeight = height;
          entries.forEach(({
            contentBoxSize,
            contentRect,
            target
          }) => {
            if (target && target !== swiper.el) return;
            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
          });

          if (newWidth !== width || newHeight !== height) {
            resizeHandler();
          }
        });
        observer.observe(swiper.el);
      };

      const removeObserver = () => {
        if (observer && observer.unobserve && swiper.el) {
          observer.unobserve(swiper.el);
          observer = null;
        }
      };

      const orientationChangeHandler = () => {
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit('orientationchange');
      };

      on('init', () => {
        if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
          createObserver();
          return;
        }

        window.addEventListener('resize', resizeHandler);
        window.addEventListener('orientationchange', orientationChangeHandler);
      });
      on('destroy', () => {
        removeObserver();
        window.removeEventListener('resize', resizeHandler);
        window.removeEventListener('orientationchange', orientationChangeHandler);
      });
    }

    function Observer({
      swiper,
      extendParams,
      on,
      emit
    }) {
      const observers = [];
      const window = getWindow();

      const attach = (target, options = {}) => {
        const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
        const observer = new ObserverFunc(mutations => {
          // The observerUpdate event should only be triggered
          // once despite the number of mutations.  Additional
          // triggers are redundant and are very costly
          if (mutations.length === 1) {
            emit('observerUpdate', mutations[0]);
            return;
          }

          const observerUpdate = function observerUpdate() {
            emit('observerUpdate', mutations[0]);
          };

          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(observerUpdate);
          } else {
            window.setTimeout(observerUpdate, 0);
          }
        });
        observer.observe(target, {
          attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
          childList: typeof options.childList === 'undefined' ? true : options.childList,
          characterData: typeof options.characterData === 'undefined' ? true : options.characterData
        });
        observers.push(observer);
      };

      const init = () => {
        if (!swiper.params.observer) return;

        if (swiper.params.observeParents) {
          const containerParents = swiper.$el.parents();

          for (let i = 0; i < containerParents.length; i += 1) {
            attach(containerParents[i]);
          }
        } // Observe container


        attach(swiper.$el[0], {
          childList: swiper.params.observeSlideChildren
        }); // Observe wrapper

        attach(swiper.$wrapperEl[0], {
          attributes: false
        });
      };

      const destroy = () => {
        observers.forEach(observer => {
          observer.disconnect();
        });
        observers.splice(0, observers.length);
      };

      extendParams({
        observer: false,
        observeParents: false,
        observeSlideChildren: false
      });
      on('init', init);
      on('destroy', destroy);
    }

    /* eslint-disable no-underscore-dangle */
    var eventsEmitter = {
      on(events, handler, priority) {
        const self = this;
        if (typeof handler !== 'function') return self;
        const method = priority ? 'unshift' : 'push';
        events.split(' ').forEach(event => {
          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
          self.eventsListeners[event][method](handler);
        });
        return self;
      },

      once(events, handler, priority) {
        const self = this;
        if (typeof handler !== 'function') return self;

        function onceHandler(...args) {
          self.off(events, onceHandler);

          if (onceHandler.__emitterProxy) {
            delete onceHandler.__emitterProxy;
          }

          handler.apply(self, args);
        }

        onceHandler.__emitterProxy = handler;
        return self.on(events, onceHandler, priority);
      },

      onAny(handler, priority) {
        const self = this;
        if (typeof handler !== 'function') return self;
        const method = priority ? 'unshift' : 'push';

        if (self.eventsAnyListeners.indexOf(handler) < 0) {
          self.eventsAnyListeners[method](handler);
        }

        return self;
      },

      offAny(handler) {
        const self = this;
        if (!self.eventsAnyListeners) return self;
        const index = self.eventsAnyListeners.indexOf(handler);

        if (index >= 0) {
          self.eventsAnyListeners.splice(index, 1);
        }

        return self;
      },

      off(events, handler) {
        const self = this;
        if (!self.eventsListeners) return self;
        events.split(' ').forEach(event => {
          if (typeof handler === 'undefined') {
            self.eventsListeners[event] = [];
          } else if (self.eventsListeners[event]) {
            self.eventsListeners[event].forEach((eventHandler, index) => {
              if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                self.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self;
      },

      emit(...args) {
        const self = this;
        if (!self.eventsListeners) return self;
        let events;
        let data;
        let context;

        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          events = args[0];
          data = args.slice(1, args.length);
          context = self;
        } else {
          events = args[0].events;
          data = args[0].data;
          context = args[0].context || self;
        }

        data.unshift(context);
        const eventsArray = Array.isArray(events) ? events : events.split(' ');
        eventsArray.forEach(event => {
          if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
            self.eventsAnyListeners.forEach(eventHandler => {
              eventHandler.apply(context, [event, ...data]);
            });
          }

          if (self.eventsListeners && self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(eventHandler => {
              eventHandler.apply(context, data);
            });
          }
        });
        return self;
      }

    };

    function updateSize() {
      const swiper = this;
      let width;
      let height;
      const $el = swiper.$el;

      if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
        width = swiper.params.width;
      } else {
        width = $el[0].clientWidth;
      }

      if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
        height = swiper.params.height;
      } else {
        height = $el[0].clientHeight;
      }

      if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
        return;
      } // Subtract paddings


      width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
      height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
      if (Number.isNaN(width)) width = 0;
      if (Number.isNaN(height)) height = 0;
      Object.assign(swiper, {
        width,
        height,
        size: swiper.isHorizontal() ? width : height
      });
    }

    function updateSlides() {
      const swiper = this;

      function getDirectionLabel(property) {
        if (swiper.isHorizontal()) {
          return property;
        } // prettier-ignore


        return {
          'width': 'height',
          'margin-top': 'margin-left',
          'margin-bottom ': 'margin-right',
          'margin-left': 'margin-top',
          'margin-right': 'margin-bottom',
          'padding-left': 'padding-top',
          'padding-right': 'padding-bottom',
          'marginRight': 'marginBottom'
        }[property];
      }

      function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
      }

      const params = swiper.params;
      const {
        $wrapperEl,
        size: swiperSize,
        rtlTranslate: rtl,
        wrongRTL
      } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
      const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
      const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
      let snapGrid = [];
      const slidesGrid = [];
      const slidesSizesGrid = [];
      let offsetBefore = params.slidesOffsetBefore;

      if (typeof offsetBefore === 'function') {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
      }

      let offsetAfter = params.slidesOffsetAfter;

      if (typeof offsetAfter === 'function') {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
      }

      const previousSnapGridLength = swiper.snapGrid.length;
      const previousSlidesGridLength = swiper.slidesGrid.length;
      let spaceBetween = params.spaceBetween;
      let slidePosition = -offsetBefore;
      let prevSlideSize = 0;
      let index = 0;

      if (typeof swiperSize === 'undefined') {
        return;
      }

      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
      }

      swiper.virtualSize = -spaceBetween; // reset margins

      if (rtl) slides.css({
        marginLeft: '',
        marginBottom: '',
        marginTop: ''
      });else slides.css({
        marginRight: '',
        marginBottom: '',
        marginTop: ''
      }); // reset cssMode offsets

      if (params.centeredSlides && params.cssMode) {
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');
      }

      const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;

      if (gridEnabled) {
        swiper.grid.initSlides(slidesLength);
      } // Calc slides


      let slideSize;
      const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
        return typeof params.breakpoints[key].slidesPerView !== 'undefined';
      }).length > 0;

      for (let i = 0; i < slidesLength; i += 1) {
        slideSize = 0;
        const slide = slides.eq(i);

        if (gridEnabled) {
          swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
        }

        if (slide.css('display') === 'none') continue; // eslint-disable-line

        if (params.slidesPerView === 'auto') {
          if (shouldResetSlideSize) {
            slides[i].style[getDirectionLabel('width')] = ``;
          }

          const slideStyles = getComputedStyle(slide[0]);
          const currentTransform = slide[0].style.transform;
          const currentWebKitTransform = slide[0].style.webkitTransform;

          if (currentTransform) {
            slide[0].style.transform = 'none';
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = 'none';
          }

          if (params.roundLengths) {
            slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
          } else {
            // eslint-disable-next-line
            const width = getDirectionPropertyValue(slideStyles, 'width');
            const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
            const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
            const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
            const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
            const boxSizing = slideStyles.getPropertyValue('box-sizing');

            if (boxSizing && boxSizing === 'border-box') {
              slideSize = width + marginLeft + marginRight;
            } else {
              const {
                clientWidth,
                offsetWidth
              } = slide[0];
              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
            }
          }

          if (currentTransform) {
            slide[0].style.transform = currentTransform;
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = currentWebKitTransform;
          }

          if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
          if (params.roundLengths) slideSize = Math.floor(slideSize);

          if (slides[i]) {
            slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
          }
        }

        if (slides[i]) {
          slides[i].swiperSlideSize = slideSize;
        }

        slidesSizesGrid.push(slideSize);

        if (params.centeredSlides) {
          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
          if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
        } else {
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
          slidePosition = slidePosition + slideSize + spaceBetween;
        }

        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index += 1;
      }

      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;

      if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
        $wrapperEl.css({
          width: `${swiper.virtualSize + params.spaceBetween}px`
        });
      }

      if (params.setWrapperSize) {
        $wrapperEl.css({
          [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`
        });
      }

      if (gridEnabled) {
        swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
      } // Remove last grid elements depending on width


      if (!params.centeredSlides) {
        const newSlidesGrid = [];

        for (let i = 0; i < snapGrid.length; i += 1) {
          let slidesGridItem = snapGrid[i];
          if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);

          if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
            newSlidesGrid.push(slidesGridItem);
          }
        }

        snapGrid = newSlidesGrid;

        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
          snapGrid.push(swiper.virtualSize - swiperSize);
        }
      }

      if (snapGrid.length === 0) snapGrid = [0];

      if (params.spaceBetween !== 0) {
        const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
        slides.filter((_, slideIndex) => {
          if (!params.cssMode) return true;

          if (slideIndex === slides.length - 1) {
            return false;
          }

          return true;
        }).css({
          [key]: `${spaceBetween}px`
        });
      }

      if (params.centeredSlides && params.centeredSlidesBounds) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach(slideSizeValue => {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        const maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map(snap => {
          if (snap < 0) return -offsetBefore;
          if (snap > maxSnap) return maxSnap + offsetAfter;
          return snap;
        });
      }

      if (params.centerInsufficientSlides) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach(slideSizeValue => {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;

        if (allSlidesSize < swiperSize) {
          const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
          snapGrid.forEach((snap, snapIndex) => {
            snapGrid[snapIndex] = snap - allSlidesOffset;
          });
          slidesGrid.forEach((snap, snapIndex) => {
            slidesGrid[snapIndex] = snap + allSlidesOffset;
          });
        }
      }

      Object.assign(swiper, {
        slides,
        snapGrid,
        slidesGrid,
        slidesSizesGrid
      });

      if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
        setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
        const addToSnapGrid = -swiper.snapGrid[0];
        const addToSlidesGrid = -swiper.slidesGrid[0];
        swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
        swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
      }

      if (slidesLength !== previousSlidesLength) {
        swiper.emit('slidesLengthChange');
      }

      if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit('snapGridLengthChange');
      }

      if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit('slidesGridLengthChange');
      }

      if (params.watchSlidesProgress) {
        swiper.updateSlidesOffset();
      }
    }

    function updateAutoHeight(speed) {
      const swiper = this;
      const activeSlides = [];
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      let newHeight = 0;
      let i;

      if (typeof speed === 'number') {
        swiper.setTransition(speed);
      } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
      }

      const getSlideByIndex = index => {
        if (isVirtual) {
          return swiper.slides.filter(el => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];
        }

        return swiper.slides.eq(index)[0];
      }; // Find slides currently in view


      if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
          swiper.visibleSlides.each(slide => {
            activeSlides.push(slide);
          });
        } else {
          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
            const index = swiper.activeIndex + i;
            if (index > swiper.slides.length && !isVirtual) break;
            activeSlides.push(getSlideByIndex(index));
          }
        }
      } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
      } // Find new height from highest slide in view


      for (i = 0; i < activeSlides.length; i += 1) {
        if (typeof activeSlides[i] !== 'undefined') {
          const height = activeSlides[i].offsetHeight;
          newHeight = height > newHeight ? height : newHeight;
        }
      } // Update Height


      if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
    }

    function updateSlidesOffset() {
      const swiper = this;
      const slides = swiper.slides;

      for (let i = 0; i < slides.length; i += 1) {
        slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
      }
    }

    function updateSlidesProgress(translate = this && this.translate || 0) {
      const swiper = this;
      const params = swiper.params;
      const {
        slides,
        rtlTranslate: rtl,
        snapGrid
      } = swiper;
      if (slides.length === 0) return;
      if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
      let offsetCenter = -translate;
      if (rtl) offsetCenter = translate; // Visible Slides

      slides.removeClass(params.slideVisibleClass);
      swiper.visibleSlidesIndexes = [];
      swiper.visibleSlides = [];

      for (let i = 0; i < slides.length; i += 1) {
        const slide = slides[i];
        let slideOffset = slide.swiperSlideOffset;

        if (params.cssMode && params.centeredSlides) {
          slideOffset -= slides[0].swiperSlideOffset;
        }

        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
        const slideBefore = -(offsetCenter - slideOffset);
        const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
        const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

        if (isVisible) {
          swiper.visibleSlides.push(slide);
          swiper.visibleSlidesIndexes.push(i);
          slides.eq(i).addClass(params.slideVisibleClass);
        }

        slide.progress = rtl ? -slideProgress : slideProgress;
        slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
      }

      swiper.visibleSlides = $(swiper.visibleSlides);
    }

    function updateProgress(translate) {
      const swiper = this;

      if (typeof translate === 'undefined') {
        const multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
      }

      const params = swiper.params;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      let {
        progress,
        isBeginning,
        isEnd
      } = swiper;
      const wasBeginning = isBeginning;
      const wasEnd = isEnd;

      if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
      } else {
        progress = (translate - swiper.minTranslate()) / translatesDiff;
        isBeginning = progress <= 0;
        isEnd = progress >= 1;
      }

      Object.assign(swiper, {
        progress,
        isBeginning,
        isEnd
      });
      if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

      if (isBeginning && !wasBeginning) {
        swiper.emit('reachBeginning toEdge');
      }

      if (isEnd && !wasEnd) {
        swiper.emit('reachEnd toEdge');
      }

      if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
        swiper.emit('fromEdge');
      }

      swiper.emit('progress', progress);
    }

    function updateSlidesClasses() {
      const swiper = this;
      const {
        slides,
        params,
        $wrapperEl,
        activeIndex,
        realIndex
      } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
      let activeSlide;

      if (isVirtual) {
        activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
      } else {
        activeSlide = slides.eq(activeIndex);
      } // Active classes


      activeSlide.addClass(params.slideActiveClass);

      if (params.loop) {
        // Duplicate to all looped slides
        if (activeSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
        }
      } // Next Slide


      let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);

      if (params.loop && nextSlide.length === 0) {
        nextSlide = slides.eq(0);
        nextSlide.addClass(params.slideNextClass);
      } // Prev Slide


      let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);

      if (params.loop && prevSlide.length === 0) {
        prevSlide = slides.eq(-1);
        prevSlide.addClass(params.slidePrevClass);
      }

      if (params.loop) {
        // Duplicate to all looped slides
        if (nextSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
        }

        if (prevSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
        }
      }

      swiper.emitSlidesClasses();
    }

    function updateActiveIndex(newActiveIndex) {
      const swiper = this;
      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      const {
        slidesGrid,
        snapGrid,
        params,
        activeIndex: previousIndex,
        realIndex: previousRealIndex,
        snapIndex: previousSnapIndex
      } = swiper;
      let activeIndex = newActiveIndex;
      let snapIndex;

      if (typeof activeIndex === 'undefined') {
        for (let i = 0; i < slidesGrid.length; i += 1) {
          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
              activeIndex = i;
            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
              activeIndex = i + 1;
            }
          } else if (translate >= slidesGrid[i]) {
            activeIndex = i;
          }
        } // Normalize slideIndex


        if (params.normalizeSlideIndex) {
          if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
        }
      }

      if (snapGrid.indexOf(translate) >= 0) {
        snapIndex = snapGrid.indexOf(translate);
      } else {
        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
      }

      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
          swiper.snapIndex = snapIndex;
          swiper.emit('snapIndexChange');
        }

        return;
      } // Get real index


      const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
      Object.assign(swiper, {
        snapIndex,
        realIndex,
        previousIndex,
        activeIndex
      });
      swiper.emit('activeIndexChange');
      swiper.emit('snapIndexChange');

      if (previousRealIndex !== realIndex) {
        swiper.emit('realIndexChange');
      }

      if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        swiper.emit('slideChange');
      }
    }

    function updateClickedSlide(e) {
      const swiper = this;
      const params = swiper.params;
      const slide = $(e.target).closest(`.${params.slideClass}`)[0];
      let slideFound = false;
      let slideIndex;

      if (slide) {
        for (let i = 0; i < swiper.slides.length; i += 1) {
          if (swiper.slides[i] === slide) {
            slideFound = true;
            slideIndex = i;
            break;
          }
        }
      }

      if (slide && slideFound) {
        swiper.clickedSlide = slide;

        if (swiper.virtual && swiper.params.virtual.enabled) {
          swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
        } else {
          swiper.clickedIndex = slideIndex;
        }
      } else {
        swiper.clickedSlide = undefined;
        swiper.clickedIndex = undefined;
        return;
      }

      if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
      }
    }

    var update = {
      updateSize,
      updateSlides,
      updateAutoHeight,
      updateSlidesOffset,
      updateSlidesProgress,
      updateProgress,
      updateSlidesClasses,
      updateActiveIndex,
      updateClickedSlide
    };

    function getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {
      const swiper = this;
      const {
        params,
        rtlTranslate: rtl,
        translate,
        $wrapperEl
      } = swiper;

      if (params.virtualTranslate) {
        return rtl ? -translate : translate;
      }

      if (params.cssMode) {
        return translate;
      }

      let currentTranslate = getTranslate($wrapperEl[0], axis);
      if (rtl) currentTranslate = -currentTranslate;
      return currentTranslate || 0;
    }

    function setTranslate(translate, byController) {
      const swiper = this;
      const {
        rtlTranslate: rtl,
        params,
        $wrapperEl,
        wrapperEl,
        progress
      } = swiper;
      let x = 0;
      let y = 0;
      const z = 0;

      if (swiper.isHorizontal()) {
        x = rtl ? -translate : translate;
      } else {
        y = translate;
      }

      if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
      }

      if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
      } else if (!params.virtualTranslate) {
        $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
      }

      swiper.previousTranslate = swiper.translate;
      swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== progress) {
        swiper.updateProgress(translate);
      }

      swiper.emit('setTranslate', swiper.translate, byController);
    }

    function minTranslate() {
      return -this.snapGrid[0];
    }

    function maxTranslate() {
      return -this.snapGrid[this.snapGrid.length - 1];
    }

    function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
      const swiper = this;
      const {
        params,
        wrapperEl
      } = swiper;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
      }

      const minTranslate = swiper.minTranslate();
      const maxTranslate = swiper.maxTranslate();
      let newTranslate;
      if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

      swiper.updateProgress(newTranslate);

      if (params.cssMode) {
        const isH = swiper.isHorizontal();

        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        } else {
          if (!swiper.support.smoothScroll) {
            animateCSSModeScroll({
              swiper,
              targetPosition: -newTranslate,
              side: isH ? 'left' : 'top'
            });
            return true;
          }

          wrapperEl.scrollTo({
            [isH ? 'left' : 'top']: -newTranslate,
            behavior: 'smooth'
          });
        }

        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionEnd');
        }
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionStart');
        }

        if (!swiper.animating) {
          swiper.animating = true;

          if (!swiper.onTranslateToWrapperTransitionEnd) {
            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
              swiper.onTranslateToWrapperTransitionEnd = null;
              delete swiper.onTranslateToWrapperTransitionEnd;

              if (runCallbacks) {
                swiper.emit('transitionEnd');
              }
            };
          }

          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
        }
      }

      return true;
    }

    var translate = {
      getTranslate: getSwiperTranslate,
      setTranslate,
      minTranslate,
      maxTranslate,
      translateTo
    };

    function setTransition(duration, byController) {
      const swiper = this;

      if (!swiper.params.cssMode) {
        swiper.$wrapperEl.transition(duration);
      }

      swiper.emit('setTransition', duration, byController);
    }

    function transitionEmit({
      swiper,
      runCallbacks,
      direction,
      step
    }) {
      const {
        activeIndex,
        previousIndex
      } = swiper;
      let dir = direction;

      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
      }

      swiper.emit(`transition${step}`);

      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit(`slideResetTransition${step}`);
          return;
        }

        swiper.emit(`slideChangeTransition${step}`);

        if (dir === 'next') {
          swiper.emit(`slideNextTransition${step}`);
        } else {
          swiper.emit(`slidePrevTransition${step}`);
        }
      }
    }

    function transitionStart(runCallbacks = true, direction) {
      const swiper = this;
      const {
        params
      } = swiper;
      if (params.cssMode) return;

      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }

      transitionEmit({
        swiper,
        runCallbacks,
        direction,
        step: 'Start'
      });
    }

    function transitionEnd(runCallbacks = true, direction) {
      const swiper = this;
      const {
        params
      } = swiper;
      swiper.animating = false;
      if (params.cssMode) return;
      swiper.setTransition(0);
      transitionEmit({
        swiper,
        runCallbacks,
        direction,
        step: 'End'
      });
    }

    var transition = {
      setTransition,
      transitionStart,
      transitionEnd
    };

    function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
      if (typeof index !== 'number' && typeof index !== 'string') {
        throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
      }

      if (typeof index === 'string') {
        /**
         * The `index` argument converted from `string` to `number`.
         * @type {number}
         */
        const indexAsNumber = parseInt(index, 10);
        /**
         * Determines whether the `index` argument is a valid `number`
         * after being converted from the `string` type.
         * @type {boolean}
         */

        const isValidNumber = isFinite(indexAsNumber);

        if (!isValidNumber) {
          throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
        } // Knowing that the converted `index` is a valid number,
        // we can update the original argument's value.


        index = indexAsNumber;
      }

      const swiper = this;
      let slideIndex = index;
      if (slideIndex < 0) slideIndex = 0;
      const {
        params,
        snapGrid,
        slidesGrid,
        previousIndex,
        activeIndex,
        rtlTranslate: rtl,
        wrapperEl,
        enabled
      } = swiper;

      if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
        return false;
      }

      const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
      let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
        swiper.emit('beforeSlideChangeStart');
      }

      const translate = -snapGrid[snapIndex]; // Update progress

      swiper.updateProgress(translate); // Normalize slideIndex

      if (params.normalizeSlideIndex) {
        for (let i = 0; i < slidesGrid.length; i += 1) {
          const normalizedTranslate = -Math.floor(translate * 100);
          const normalizedGrid = Math.floor(slidesGrid[i] * 100);
          const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
              slideIndex = i;
            } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
              slideIndex = i + 1;
            }
          } else if (normalizedTranslate >= normalizedGrid) {
            slideIndex = i;
          }
        }
      } // Directions locks


      if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
          return false;
        }

        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
          if ((activeIndex || 0) !== slideIndex) return false;
        }
      }

      let direction;
      if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

      if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
        swiper.updateActiveIndex(slideIndex); // Update Height

        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }

        swiper.updateSlidesClasses();

        if (params.effect !== 'slide') {
          swiper.setTranslate(translate);
        }

        if (direction !== 'reset') {
          swiper.transitionStart(runCallbacks, direction);
          swiper.transitionEnd(runCallbacks, direction);
        }

        return false;
      }

      if (params.cssMode) {
        const isH = swiper.isHorizontal();
        const t = rtl ? translate : -translate;

        if (speed === 0) {
          const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

          if (isVirtual) {
            swiper.wrapperEl.style.scrollSnapType = 'none';
            swiper._immediateVirtual = true;
          }

          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;

          if (isVirtual) {
            requestAnimationFrame(() => {
              swiper.wrapperEl.style.scrollSnapType = '';
              swiper._swiperImmediateVirtual = false;
            });
          }
        } else {
          if (!swiper.support.smoothScroll) {
            animateCSSModeScroll({
              swiper,
              targetPosition: t,
              side: isH ? 'left' : 'top'
            });
            return true;
          }

          wrapperEl.scrollTo({
            [isH ? 'left' : 'top']: t,
            behavior: 'smooth'
          });
        }

        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);

        if (!swiper.animating) {
          swiper.animating = true;

          if (!swiper.onSlideToWrapperTransitionEnd) {
            swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
              swiper.onSlideToWrapperTransitionEnd = null;
              delete swiper.onSlideToWrapperTransitionEnd;
              swiper.transitionEnd(runCallbacks, direction);
            };
          }

          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
        }
      }

      return true;
    }

    function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      let newIndex = index;

      if (swiper.params.loop) {
        newIndex += swiper.loopedSlides;
      }

      return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      const {
        animating,
        enabled,
        params
      } = swiper;
      if (!enabled) return swiper;
      let perGroup = params.slidesPerGroup;

      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
      }

      const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      const {
        params,
        animating,
        snapGrid,
        slidesGrid,
        rtlTranslate,
        enabled
      } = swiper;
      if (!enabled) return swiper;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      const translate = rtlTranslate ? swiper.translate : -swiper.translate;

      function normalize(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
      }

      const normalizedTranslate = normalize(translate);
      const normalizedSnapGrid = snapGrid.map(val => normalize(val));
      let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

      if (typeof prevSnap === 'undefined' && params.cssMode) {
        let prevSnapIndex;
        snapGrid.forEach((snap, snapIndex) => {
          if (normalizedTranslate >= snap) {
            // prevSnap = snap;
            prevSnapIndex = snapIndex;
          }
        });

        if (typeof prevSnapIndex !== 'undefined') {
          prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
        }
      }

      let prevIndex = 0;

      if (typeof prevSnap !== 'undefined') {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;

        if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
          prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
          prevIndex = Math.max(prevIndex, 0);
        }
      }

      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
      const swiper = this;
      let index = swiper.activeIndex;
      const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
      const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

      if (translate >= swiper.snapGrid[snapIndex]) {
        // The current translate is on or after the current snap index, so the choice
        // is between the current index and the one after it.
        const currentSnap = swiper.snapGrid[snapIndex];
        const nextSnap = swiper.snapGrid[snapIndex + 1];

        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
          index += swiper.params.slidesPerGroup;
        }
      } else {
        // The current translate is before the current snap index, so the choice
        // is between the current index and the one before it.
        const prevSnap = swiper.snapGrid[snapIndex - 1];
        const currentSnap = swiper.snapGrid[snapIndex];

        if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
          index -= swiper.params.slidesPerGroup;
        }
      }

      index = Math.max(index, 0);
      index = Math.min(index, swiper.slidesGrid.length - 1);
      return swiper.slideTo(index, speed, runCallbacks, internal);
    }

    function slideToClickedSlide() {
      const swiper = this;
      const {
        params,
        $wrapperEl
      } = swiper;
      const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
      let slideToIndex = swiper.clickedIndex;
      let realIndex;

      if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

        if (params.centeredSlides) {
          if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
            swiper.loopFix();
            slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
            nextTick(() => {
              swiper.slideTo(slideToIndex);
            });
          } else {
            swiper.slideTo(slideToIndex);
          }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
          nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else {
        swiper.slideTo(slideToIndex);
      }
    }

    var slide = {
      slideTo,
      slideToLoop,
      slideNext,
      slidePrev,
      slideReset,
      slideToClosest,
      slideToClickedSlide
    };

    function loopCreate() {
      const swiper = this;
      const document = getDocument();
      const {
        params,
        $wrapperEl
      } = swiper; // Remove duplicated slides

      const $selector = $($wrapperEl.children()[0].parentNode);
      $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
      let slides = $selector.children(`.${params.slideClass}`);

      if (params.loopFillGroupWithBlank) {
        const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

        if (blankSlidesNum !== params.slidesPerGroup) {
          for (let i = 0; i < blankSlidesNum; i += 1) {
            const blankNode = $(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
            $selector.append(blankNode);
          }

          slides = $selector.children(`.${params.slideClass}`);
        }
      }

      if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
      swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
      swiper.loopedSlides += params.loopAdditionalSlides;

      if (swiper.loopedSlides > slides.length) {
        swiper.loopedSlides = slides.length;
      }

      const prependSlides = [];
      const appendSlides = [];
      slides.each((el, index) => {
        const slide = $(el);

        if (index < swiper.loopedSlides) {
          appendSlides.push(el);
        }

        if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
          prependSlides.push(el);
        }

        slide.attr('data-swiper-slide-index', index);
      });

      for (let i = 0; i < appendSlides.length; i += 1) {
        $selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }

      for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
        $selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
    }

    function loopFix() {
      const swiper = this;
      swiper.emit('beforeLoopFix');
      const {
        activeIndex,
        slides,
        loopedSlides,
        allowSlidePrev,
        allowSlideNext,
        snapGrid,
        rtlTranslate: rtl
      } = swiper;
      let newIndex;
      swiper.allowSlidePrev = true;
      swiper.allowSlideNext = true;
      const snapTranslate = -snapGrid[activeIndex];
      const diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

      if (activeIndex < loopedSlides) {
        newIndex = slides.length - loopedSlides * 3 + activeIndex;
        newIndex += loopedSlides;
        const slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      } else if (activeIndex >= slides.length - loopedSlides) {
        // Fix For Positive Oversliding
        newIndex = -slides.length + activeIndex + loopedSlides;
        newIndex += loopedSlides;
        const slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      }

      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit('loopFix');
    }

    function loopDestroy() {
      const swiper = this;
      const {
        $wrapperEl,
        params,
        slides
      } = swiper;
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
      slides.removeAttr('data-swiper-slide-index');
    }

    var loop = {
      loopCreate,
      loopFix,
      loopDestroy
    };

    function setGrabCursor(moving) {
      const swiper = this;
      if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
      const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
      el.style.cursor = 'move';
      el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
      el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
      el.style.cursor = moving ? 'grabbing' : 'grab';
    }

    function unsetGrabCursor() {
      const swiper = this;

      if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
        return;
      }

      swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
    }

    var grabCursor = {
      setGrabCursor,
      unsetGrabCursor
    };

    function closestElement(selector, base = this) {
      function __closestFrom(el) {
        if (!el || el === getDocument() || el === getWindow()) return null;
        if (el.assignedSlot) el = el.assignedSlot;
        const found = el.closest(selector);
        return found || __closestFrom(el.getRootNode().host);
      }

      return __closestFrom(base);
    }

    function onTouchStart(event) {
      const swiper = this;
      const document = getDocument();
      const window = getWindow();
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        enabled
      } = swiper;
      if (!enabled) return;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return;
      }

      if (!swiper.animating && params.cssMode && params.loop) {
        swiper.loopFix();
      }

      let e = event;
      if (e.originalEvent) e = e.originalEvent;
      let $targetEl = $(e.target);

      if (params.touchEventsTarget === 'wrapper') {
        if (!$targetEl.closest(swiper.wrapperEl).length) return;
      }

      data.isTouchEvent = e.type === 'touchstart';
      if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
      if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
      if (data.isTouched && data.isMoved) return; // change target el for shadow root component

      const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

      if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
        $targetEl = $(event.path[0]);
      }

      const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
      const isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
        swiper.allowClick = true;
        return;
      }

      if (params.swipeHandler) {
        if (!$targetEl.closest(params.swipeHandler)[0]) return;
      }

      touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      const startX = touches.currentX;
      const startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

      const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
      const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === 'prevent') {
          event.preventDefault();
        } else {
          return;
        }
      }

      Object.assign(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: undefined,
        startMoving: undefined
      });
      touches.startX = startX;
      touches.startY = startY;
      data.touchStartTime = now();
      swiper.allowClick = true;
      swiper.updateSize();
      swiper.swipeDirection = undefined;
      if (params.threshold > 0) data.allowThresholdMove = false;

      if (e.type !== 'touchstart') {
        let preventDefault = true;
        if ($targetEl.is(data.focusableElements)) preventDefault = false;

        if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
          document.activeElement.blur();
        }

        const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
          e.preventDefault();
        }
      }

      swiper.emit('touchStart', e);
    }

    function onTouchMove(event) {
      const document = getDocument();
      const swiper = this;
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        rtlTranslate: rtl,
        enabled
      } = swiper;
      if (!enabled) return;
      let e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
          swiper.emit('touchMoveOpposite', e);
        }

        return;
      }

      if (data.isTouchEvent && e.type !== 'touchmove') return;
      const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
      const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

      if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
      }

      if (!swiper.allowTouchMove) {
        // isMoved = true;
        swiper.allowClick = false;

        if (data.isTouched) {
          Object.assign(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY
          });
          data.touchStartTime = now();
        }

        return;
      }

      if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
          // Vertical
          if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
            data.isTouched = false;
            data.isMoved = false;
            return;
          }
        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
          return;
        }
      }

      if (data.isTouchEvent && document.activeElement) {
        if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
          data.isMoved = true;
          swiper.allowClick = false;
          return;
        }
      }

      if (data.allowTouchCallbacks) {
        swiper.emit('touchMove', e);
      }

      if (e.targetTouches && e.targetTouches.length > 1) return;
      touches.currentX = pageX;
      touches.currentY = pageY;
      const diffX = touches.currentX - touches.startX;
      const diffY = touches.currentY - touches.startY;
      if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;

      if (typeof data.isScrolling === 'undefined') {
        let touchAngle;

        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
          data.isScrolling = false;
        } else {
          // eslint-disable-next-line
          if (diffX * diffX + diffY * diffY >= 25) {
            touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
          }
        }
      }

      if (data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }

      if (typeof data.startMoving === 'undefined') {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
          data.startMoving = true;
        }
      }

      if (data.isScrolling) {
        data.isTouched = false;
        return;
      }

      if (!data.startMoving) {
        return;
      }

      swiper.allowClick = false;

      if (!params.cssMode && e.cancelable) {
        e.preventDefault();
      }

      if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
      }

      if (!data.isMoved) {
        if (params.loop && !params.cssMode) {
          swiper.loopFix();
        }

        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);

        if (swiper.animating) {
          swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
        }

        data.allowMomentumBounce = false; // Grab Cursor

        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
          swiper.setGrabCursor(true);
        }

        swiper.emit('sliderFirstMove', e);
      }

      swiper.emit('sliderMove', e);
      data.isMoved = true;
      let diff = swiper.isHorizontal() ? diffX : diffY;
      touches.diff = diff;
      diff *= params.touchRatio;
      if (rtl) diff = -diff;
      swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
      data.currentTranslate = diff + data.startTranslate;
      let disableParentSwiper = true;
      let resistanceRatio = params.resistanceRatio;

      if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
      }

      if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }

      if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
      } // Directions locks


      if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
      } // Threshold


      if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
          if (!data.allowThresholdMove) {
            data.allowThresholdMove = true;
            touches.startX = touches.currentX;
            touches.startY = touches.currentY;
            data.currentTranslate = data.startTranslate;
            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
            return;
          }
        } else {
          data.currentTranslate = data.startTranslate;
          return;
        }
      }

      if (!params.followFinger || params.cssMode) return; // Update active index in free mode

      if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
        swiper.freeMode.onTouchMove();
      } // Update progress


      swiper.updateProgress(data.currentTranslate); // Update translate

      swiper.setTranslate(data.currentTranslate);
    }

    function onTouchEnd(event) {
      const swiper = this;
      const data = swiper.touchEventsData;
      const {
        params,
        touches,
        rtlTranslate: rtl,
        slidesGrid,
        enabled
      } = swiper;
      if (!enabled) return;
      let e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (data.allowTouchCallbacks) {
        swiper.emit('touchEnd', e);
      }

      data.allowTouchCallbacks = false;

      if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
          swiper.setGrabCursor(false);
        }

        data.isMoved = false;
        data.startMoving = false;
        return;
      } // Return Grab Cursor


      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
      } // Time diff


      const touchEndTime = now();
      const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

      if (swiper.allowClick) {
        swiper.updateClickedSlide(e);
        swiper.emit('tap click', e);

        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
          swiper.emit('doubleTap doubleClick', e);
        }
      }

      data.lastClickTime = now();
      nextTick(() => {
        if (!swiper.destroyed) swiper.allowClick = true;
      });

      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
      }

      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      let currentPos;

      if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
      } else {
        currentPos = -data.currentTranslate;
      }

      if (params.cssMode) {
        return;
      }

      if (swiper.params.freeMode && params.freeMode.enabled) {
        swiper.freeMode.onTouchEnd({
          currentPos
        });
        return;
      } // Find current slide


      let stopIndex = 0;
      let groupSize = swiper.slidesSizesGrid[0];

      for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
        const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

        if (typeof slidesGrid[i + increment] !== 'undefined') {
          if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
            stopIndex = i;
            groupSize = slidesGrid[i + increment] - slidesGrid[i];
          }
        } else if (currentPos >= slidesGrid[i]) {
          stopIndex = i;
          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
      } // Find current slide size


      const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
      const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

      if (timeDiff > params.longSwipesMs) {
        // Long touches
        if (!params.longSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (swiper.swipeDirection === 'next') {
          if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
        }

        if (swiper.swipeDirection === 'prev') {
          if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
        }
      } else {
        // Short swipes
        if (!params.shortSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

        if (!isNavButtonTarget) {
          if (swiper.swipeDirection === 'next') {
            swiper.slideTo(stopIndex + increment);
          }

          if (swiper.swipeDirection === 'prev') {
            swiper.slideTo(stopIndex);
          }
        } else if (e.target === swiper.navigation.nextEl) {
          swiper.slideTo(stopIndex + increment);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    }

    function onResize() {
      const swiper = this;
      const {
        params,
        el
      } = swiper;
      if (el && el.offsetWidth === 0) return; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      } // Save locks


      const {
        allowSlideNext,
        allowSlidePrev,
        snapGrid
      } = swiper; // Disable locks on resize

      swiper.allowSlideNext = true;
      swiper.allowSlidePrev = true;
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateSlidesClasses();

      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.run();
      } // Return locks after resize


      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;

      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
    }

    function onClick(e) {
      const swiper = this;
      if (!swiper.enabled) return;

      if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();

        if (swiper.params.preventClicksPropagation && swiper.animating) {
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }
    }

    function onScroll() {
      const swiper = this;
      const {
        wrapperEl,
        rtlTranslate,
        enabled
      } = swiper;
      if (!enabled) return;
      swiper.previousTranslate = swiper.translate;

      if (swiper.isHorizontal()) {
        swiper.translate = -wrapperEl.scrollLeft;
      } else {
        swiper.translate = -wrapperEl.scrollTop;
      } // eslint-disable-next-line


      if (swiper.translate === -0) swiper.translate = 0;
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
      }

      swiper.emit('setTranslate', swiper.translate, false);
    }

    let dummyEventAttached = false;

    function dummyEventListener() {}

    const events = (swiper, method) => {
      const document = getDocument();
      const {
        params,
        touchEvents,
        el,
        wrapperEl,
        device,
        support
      } = swiper;
      const capture = !!params.nested;
      const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
      const swiperMethod = method; // Touch Events

      if (!support.touch) {
        el[domMethod](touchEvents.start, swiper.onTouchStart, false);
        document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
        document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
      } else {
        const passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
        el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
          passive: false,
          capture
        } : capture);
        el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);

        if (touchEvents.cancel) {
          el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
        }
      } // Prevent Links Clicks


      if (params.preventClicks || params.preventClicksPropagation) {
        el[domMethod]('click', swiper.onClick, true);
      }

      if (params.cssMode) {
        wrapperEl[domMethod]('scroll', swiper.onScroll);
      } // Resize handler


      if (params.updateOnWindowResize) {
        swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
      } else {
        swiper[swiperMethod]('observerUpdate', onResize, true);
      }
    };

    function attachEvents() {
      const swiper = this;
      const document = getDocument();
      const {
        params,
        support
      } = swiper;
      swiper.onTouchStart = onTouchStart.bind(swiper);
      swiper.onTouchMove = onTouchMove.bind(swiper);
      swiper.onTouchEnd = onTouchEnd.bind(swiper);

      if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
      }

      swiper.onClick = onClick.bind(swiper);

      if (support.touch && !dummyEventAttached) {
        document.addEventListener('touchstart', dummyEventListener);
        dummyEventAttached = true;
      }

      events(swiper, 'on');
    }

    function detachEvents() {
      const swiper = this;
      events(swiper, 'off');
    }

    var events$1 = {
      attachEvents,
      detachEvents
    };

    const isGridEnabled = (swiper, params) => {
      return swiper.grid && params.grid && params.grid.rows > 1;
    };

    function setBreakpoint() {
      const swiper = this;
      const {
        activeIndex,
        initialized,
        loopedSlides = 0,
        params,
        $el
      } = swiper;
      const breakpoints = params.breakpoints;
      if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

      const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
      if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
      const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
      const breakpointParams = breakpointOnlyParams || swiper.originalParams;
      const wasMultiRow = isGridEnabled(swiper, params);
      const isMultiRow = isGridEnabled(swiper, breakpointParams);
      const wasEnabled = params.enabled;

      if (wasMultiRow && !isMultiRow) {
        $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
        swiper.emitContainerClasses();
      } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(`${params.containerModifierClass}grid`);

        if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
          $el.addClass(`${params.containerModifierClass}grid-column`);
        }

        swiper.emitContainerClasses();
      }

      const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

      if (directionChanged && initialized) {
        swiper.changeDirection();
      }

      extend(swiper.params, breakpointParams);
      const isEnabled = swiper.params.enabled;
      Object.assign(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
      });

      if (wasEnabled && !isEnabled) {
        swiper.disable();
      } else if (!wasEnabled && isEnabled) {
        swiper.enable();
      }

      swiper.currentBreakpoint = breakpoint;
      swiper.emit('_beforeBreakpoint', breakpointParams);

      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
      }

      swiper.emit('breakpoint', breakpointParams);
    }

    function getBreakpoint(breakpoints, base = 'window', containerEl) {
      if (!breakpoints || base === 'container' && !containerEl) return undefined;
      let breakpoint = false;
      const window = getWindow();
      const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
      const points = Object.keys(breakpoints).map(point => {
        if (typeof point === 'string' && point.indexOf('@') === 0) {
          const minRatio = parseFloat(point.substr(1));
          const value = currentHeight * minRatio;
          return {
            value,
            point
          };
        }

        return {
          value: point,
          point
        };
      });
      points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));

      for (let i = 0; i < points.length; i += 1) {
        const {
          point,
          value
        } = points[i];

        if (base === 'window') {
          if (window.matchMedia(`(min-width: ${value}px)`).matches) {
            breakpoint = point;
          }
        } else if (value <= containerEl.clientWidth) {
          breakpoint = point;
        }
      }

      return breakpoint || 'max';
    }

    var breakpoints = {
      setBreakpoint,
      getBreakpoint
    };

    function prepareClasses(entries, prefix) {
      const resultClasses = [];
      entries.forEach(item => {
        if (typeof item === 'object') {
          Object.keys(item).forEach(classNames => {
            if (item[classNames]) {
              resultClasses.push(prefix + classNames);
            }
          });
        } else if (typeof item === 'string') {
          resultClasses.push(prefix + item);
        }
      });
      return resultClasses;
    }

    function addClasses() {
      const swiper = this;
      const {
        classNames,
        params,
        rtl,
        $el,
        device,
        support
      } = swiper; // prettier-ignore

      const suffixes = prepareClasses(['initialized', params.direction, {
        'pointer-events': !support.touch
      }, {
        'free-mode': swiper.params.freeMode && params.freeMode.enabled
      }, {
        'autoheight': params.autoHeight
      }, {
        'rtl': rtl
      }, {
        'grid': params.grid && params.grid.rows > 1
      }, {
        'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
      }, {
        'android': device.android
      }, {
        'ios': device.ios
      }, {
        'css-mode': params.cssMode
      }, {
        'centered': params.cssMode && params.centeredSlides
      }], params.containerModifierClass);
      classNames.push(...suffixes);
      $el.addClass([...classNames].join(' '));
      swiper.emitContainerClasses();
    }

    function removeClasses() {
      const swiper = this;
      const {
        $el,
        classNames
      } = swiper;
      $el.removeClass(classNames.join(' '));
      swiper.emitContainerClasses();
    }

    var classes = {
      addClasses,
      removeClasses
    };

    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
      const window = getWindow();
      let image;

      function onReady() {
        if (callback) callback();
      }

      const isPicture = $(imageEl).parent('picture')[0];

      if (!isPicture && (!imageEl.complete || !checkForComplete)) {
        if (src) {
          image = new window.Image();
          image.onload = onReady;
          image.onerror = onReady;

          if (sizes) {
            image.sizes = sizes;
          }

          if (srcset) {
            image.srcset = srcset;
          }

          if (src) {
            image.src = src;
          }
        } else {
          onReady();
        }
      } else {
        // image already loaded...
        onReady();
      }
    }

    function preloadImages() {
      const swiper = this;
      swiper.imagesToLoad = swiper.$el.find('img');

      function onReady() {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
        if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

        if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
          if (swiper.params.updateOnImagesReady) swiper.update();
          swiper.emit('imagesReady');
        }
      }

      for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
        const imageEl = swiper.imagesToLoad[i];
        swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
      }
    }

    var images = {
      loadImage,
      preloadImages
    };

    function checkOverflow() {
      const swiper = this;
      const {
        isLocked: wasLocked,
        params
      } = swiper;
      const {
        slidesOffsetBefore
      } = params;

      if (slidesOffsetBefore) {
        const lastSlideIndex = swiper.slides.length - 1;
        const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
        swiper.isLocked = swiper.size > lastSlideRightEdge;
      } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
      }

      if (params.allowSlideNext === true) {
        swiper.allowSlideNext = !swiper.isLocked;
      }

      if (params.allowSlidePrev === true) {
        swiper.allowSlidePrev = !swiper.isLocked;
      }

      if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
      }

      if (wasLocked !== swiper.isLocked) {
        swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
      }
    }

    var checkOverflow$1 = {
      checkOverflow
    };

    var defaults = {
      init: true,
      direction: 'horizontal',
      touchEventsTarget: 'wrapper',
      initialSlide: 0,
      speed: 300,
      cssMode: false,
      updateOnWindowResize: true,
      resizeObserver: true,
      nested: false,
      createElements: false,
      enabled: true,
      focusableElements: 'input, select, option, textarea, button, video, label',
      // Overrides
      width: null,
      height: null,
      //
      preventInteractionOnTransition: false,
      // ssr
      userAgent: null,
      url: null,
      // To support iOS's swipe-to-go-back gesture (when being used in-app).
      edgeSwipeDetection: false,
      edgeSwipeThreshold: 20,
      // Autoheight
      autoHeight: false,
      // Set wrapper width
      setWrapperSize: false,
      // Virtual Translate
      virtualTranslate: false,
      // Effects
      effect: 'slide',
      // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
      // Breakpoints
      breakpoints: undefined,
      breakpointsBase: 'window',
      // Slides grid
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      slidesPerGroupAuto: false,
      centeredSlides: false,
      centeredSlidesBounds: false,
      slidesOffsetBefore: 0,
      // in px
      slidesOffsetAfter: 0,
      // in px
      normalizeSlideIndex: true,
      centerInsufficientSlides: false,
      // Disable swiper and hide navigation when container not overflow
      watchOverflow: true,
      // Round length
      roundLengths: false,
      // Touches
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: true,
      shortSwipes: true,
      longSwipes: true,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: true,
      allowTouchMove: true,
      threshold: 0,
      touchMoveStopPropagation: false,
      touchStartPreventDefault: true,
      touchStartForcePreventDefault: false,
      touchReleaseOnEdges: false,
      // Unique Navigation Elements
      uniqueNavElements: true,
      // Resistance
      resistance: true,
      resistanceRatio: 0.85,
      // Progress
      watchSlidesProgress: false,
      // Cursor
      grabCursor: false,
      // Clicks
      preventClicks: true,
      preventClicksPropagation: true,
      slideToClickedSlide: false,
      // Images
      preloadImages: true,
      updateOnImagesReady: true,
      // loop
      loop: false,
      loopAdditionalSlides: 0,
      loopedSlides: null,
      loopFillGroupWithBlank: false,
      loopPreventsSlide: true,
      // Swiping/no swiping
      allowSlidePrev: true,
      allowSlideNext: true,
      swipeHandler: null,
      // '.swipe-handler',
      noSwiping: true,
      noSwipingClass: 'swiper-no-swiping',
      noSwipingSelector: null,
      // Passive Listeners
      passiveListeners: true,
      // NS
      containerModifierClass: 'swiper-',
      // NEW
      slideClass: 'swiper-slide',
      slideBlankClass: 'swiper-slide-invisible-blank',
      slideActiveClass: 'swiper-slide-active',
      slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
      slideVisibleClass: 'swiper-slide-visible',
      slideDuplicateClass: 'swiper-slide-duplicate',
      slideNextClass: 'swiper-slide-next',
      slideDuplicateNextClass: 'swiper-slide-duplicate-next',
      slidePrevClass: 'swiper-slide-prev',
      slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
      wrapperClass: 'swiper-wrapper',
      // Callbacks
      runCallbacksOnInit: true,
      // Internals
      _emitClasses: false
    };

    function moduleExtendParams(params, allModulesParams) {
      return function extendParams(obj = {}) {
        const moduleParamName = Object.keys(obj)[0];
        const moduleParams = obj[moduleParamName];

        if (typeof moduleParams !== 'object' || moduleParams === null) {
          extend(allModulesParams, obj);
          return;
        }

        if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
          params[moduleParamName] = {
            auto: true
          };
        }

        if (!(moduleParamName in params && 'enabled' in moduleParams)) {
          extend(allModulesParams, obj);
          return;
        }

        if (params[moduleParamName] === true) {
          params[moduleParamName] = {
            enabled: true
          };
        }

        if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
          params[moduleParamName].enabled = true;
        }

        if (!params[moduleParamName]) params[moduleParamName] = {
          enabled: false
        };
        extend(allModulesParams, obj);
      };
    }

    /* eslint no-param-reassign: "off" */
    const prototypes = {
      eventsEmitter,
      update,
      translate,
      transition,
      slide,
      loop,
      grabCursor,
      events: events$1,
      breakpoints,
      checkOverflow: checkOverflow$1,
      classes,
      images
    };
    const extendedDefaults = {};

    class Swiper {
      constructor(...args) {
        let el;
        let params;

        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
          params = args[0];
        } else {
          [el, params] = args;
        }

        if (!params) params = {};
        params = extend({}, params);
        if (el && !params.el) params.el = el;

        if (params.el && $(params.el).length > 1) {
          const swipers = [];
          $(params.el).each(containerEl => {
            const newParams = extend({}, params, {
              el: containerEl
            });
            swipers.push(new Swiper(newParams));
          });
          return swipers;
        } // Swiper Instance


        const swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
          userAgent: params.userAgent
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];
        swiper.modules = [...swiper.__modules__];

        if (params.modules && Array.isArray(params.modules)) {
          swiper.modules.push(...params.modules);
        }

        const allModulesParams = {};
        swiper.modules.forEach(mod => {
          mod({
            swiper,
            extendParams: moduleExtendParams(params, allModulesParams),
            on: swiper.on.bind(swiper),
            once: swiper.once.bind(swiper),
            off: swiper.off.bind(swiper),
            emit: swiper.emit.bind(swiper)
          });
        }); // Extend defaults with modules params

        const swiperParams = extend({}, defaults, allModulesParams); // Extend defaults with passed params

        swiper.params = extend({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = extend({}, swiper.params);
        swiper.passedParams = extend({}, params); // add event listeners

        if (swiper.params && swiper.params.on) {
          Object.keys(swiper.params.on).forEach(eventName => {
            swiper.on(eventName, swiper.params.on[eventName]);
          });
        }

        if (swiper.params && swiper.params.onAny) {
          swiper.onAny(swiper.params.onAny);
        } // Save Dom lib


        swiper.$ = $; // Extend Swiper

        Object.assign(swiper, {
          enabled: swiper.params.enabled,
          el,
          // Classes
          classNames: [],
          // Slides
          slides: $(),
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],

          // isDirection
          isHorizontal() {
            return swiper.params.direction === 'horizontal';
          },

          isVertical() {
            return swiper.params.direction === 'vertical';
          },

          // Indexes
          activeIndex: 0,
          realIndex: 0,
          //
          isBeginning: true,
          isEnd: false,
          // Props
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: false,
          // Locks
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev,
          // Touch Events
          touchEvents: function touchEvents() {
            const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
            const desktop = ['pointerdown', 'pointermove', 'pointerup'];
            swiper.touchEventsTouch = {
              start: touch[0],
              move: touch[1],
              end: touch[2],
              cancel: touch[3]
            };
            swiper.touchEventsDesktop = {
              start: desktop[0],
              move: desktop[1],
              end: desktop[2]
            };
            return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
          }(),
          touchEventsData: {
            isTouched: undefined,
            isMoved: undefined,
            allowTouchCallbacks: undefined,
            touchStartTime: undefined,
            isScrolling: undefined,
            currentTranslate: undefined,
            startTranslate: undefined,
            allowThresholdMove: undefined,
            // Form elements to match
            focusableElements: swiper.params.focusableElements,
            // Last click time
            lastClickTime: now(),
            clickTimeout: undefined,
            // Velocities
            velocities: [],
            allowMomentumBounce: undefined,
            isTouchEvent: undefined,
            startMoving: undefined
          },
          // Clicks
          allowClick: true,
          // Touches
          allowTouchMove: swiper.params.allowTouchMove,
          touches: {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
          },
          // Images
          imagesToLoad: [],
          imagesLoaded: 0
        });
        swiper.emit('_swiper'); // Init

        if (swiper.params.init) {
          swiper.init();
        } // Return app instance


        return swiper;
      }

      enable() {
        const swiper = this;
        if (swiper.enabled) return;
        swiper.enabled = true;

        if (swiper.params.grabCursor) {
          swiper.setGrabCursor();
        }

        swiper.emit('enable');
      }

      disable() {
        const swiper = this;
        if (!swiper.enabled) return;
        swiper.enabled = false;

        if (swiper.params.grabCursor) {
          swiper.unsetGrabCursor();
        }

        swiper.emit('disable');
      }

      setProgress(progress, speed) {
        const swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        const min = swiper.minTranslate();
        const max = swiper.maxTranslate();
        const current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      emitContainerClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const cls = swiper.el.className.split(' ').filter(className => {
          return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
        });
        swiper.emit('_containerClasses', cls.join(' '));
      }

      getSlideClasses(slideEl) {
        const swiper = this;
        return slideEl.className.split(' ').filter(className => {
          return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
        }).join(' ');
      }

      emitSlidesClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const updates = [];
        swiper.slides.each(slideEl => {
          const classNames = swiper.getSlideClasses(slideEl);
          updates.push({
            slideEl,
            classNames
          });
          swiper.emit('_slideClass', slideEl, classNames);
        });
        swiper.emit('_slideClasses', updates);
      }

      slidesPerViewDynamic(view = 'current', exact = false) {
        const swiper = this;
        const {
          params,
          slides,
          slidesGrid,
          slidesSizesGrid,
          size: swiperSize,
          activeIndex
        } = swiper;
        let spv = 1;

        if (params.centeredSlides) {
          let slideSize = slides[activeIndex].swiperSlideSize;
          let breakLoop;

          for (let i = activeIndex + 1; i < slides.length; i += 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }

          for (let i = activeIndex - 1; i >= 0; i -= 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }
        } else {
          // eslint-disable-next-line
          if (view === 'current') {
            for (let i = activeIndex + 1; i < slides.length; i += 1) {
              const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;

              if (slideInView) {
                spv += 1;
              }
            }
          } else {
            // previous
            for (let i = activeIndex - 1; i >= 0; i -= 1) {
              const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;

              if (slideInView) {
                spv += 1;
              }
            }
          }
        }

        return spv;
      }

      update() {
        const swiper = this;
        if (!swiper || swiper.destroyed) return;
        const {
          snapGrid,
          params
        } = swiper; // Breakpoints

        if (params.breakpoints) {
          swiper.setBreakpoint();
        }

        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();

        function setTranslate() {
          const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
          const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
          swiper.setTranslate(newTranslate);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }

        let translated;

        if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
          setTranslate();

          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        } else {
          if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
            translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
          } else {
            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
          }

          if (!translated) {
            setTranslate();
          }
        }

        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
          swiper.checkOverflow();
        }

        swiper.emit('update');
      }

      changeDirection(newDirection, needUpdate = true) {
        const swiper = this;
        const currentDirection = swiper.params.direction;

        if (!newDirection) {
          // eslint-disable-next-line
          newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
        }

        if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
          return swiper;
        }

        swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
        swiper.emitContainerClasses();
        swiper.params.direction = newDirection;
        swiper.slides.each(slideEl => {
          if (newDirection === 'vertical') {
            slideEl.style.width = '';
          } else {
            slideEl.style.height = '';
          }
        });
        swiper.emit('changeDirection');
        if (needUpdate) swiper.update();
        return swiper;
      }

      mount(el) {
        const swiper = this;
        if (swiper.mounted) return true; // Find el

        const $el = $(el || swiper.params.el);
        el = $el[0];

        if (!el) {
          return false;
        }

        el.swiper = swiper;

        const getWrapperSelector = () => {
          return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
        };

        const getWrapper = () => {
          if (el && el.shadowRoot && el.shadowRoot.querySelector) {
            const res = $(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

            res.children = options => $el.children(options);

            return res;
          }

          return $el.children(getWrapperSelector());
        }; // Find Wrapper


        let $wrapperEl = getWrapper();

        if ($wrapperEl.length === 0 && swiper.params.createElements) {
          const document = getDocument();
          const wrapper = document.createElement('div');
          $wrapperEl = $(wrapper);
          wrapper.className = swiper.params.wrapperClass;
          $el.append(wrapper);
          $el.children(`.${swiper.params.slideClass}`).each(slideEl => {
            $wrapperEl.append(slideEl);
          });
        }

        Object.assign(swiper, {
          $el,
          el,
          $wrapperEl,
          wrapperEl: $wrapperEl[0],
          mounted: true,
          // RTL
          rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
          rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
          wrongRTL: $wrapperEl.css('display') === '-webkit-box'
        });
        return true;
      }

      init(el) {
        const swiper = this;
        if (swiper.initialized) return swiper;
        const mounted = swiper.mount(el);
        if (mounted === false) return swiper;
        swiper.emit('beforeInit'); // Set breakpoint

        if (swiper.params.breakpoints) {
          swiper.setBreakpoint();
        } // Add Classes


        swiper.addClasses(); // Create loop

        if (swiper.params.loop) {
          swiper.loopCreate();
        } // Update size


        swiper.updateSize(); // Update slides

        swiper.updateSlides();

        if (swiper.params.watchOverflow) {
          swiper.checkOverflow();
        } // Set Grab Cursor


        if (swiper.params.grabCursor && swiper.enabled) {
          swiper.setGrabCursor();
        }

        if (swiper.params.preloadImages) {
          swiper.preloadImages();
        } // Slide To Initial Slide


        if (swiper.params.loop) {
          swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
        } else {
          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        } // Attach events


        swiper.attachEvents(); // Init Flag

        swiper.initialized = true; // Emit

        swiper.emit('init');
        swiper.emit('afterInit');
        return swiper;
      }

      destroy(deleteInstance = true, cleanStyles = true) {
        const swiper = this;
        const {
          params,
          $el,
          $wrapperEl,
          slides
        } = swiper;

        if (typeof swiper.params === 'undefined' || swiper.destroyed) {
          return null;
        }

        swiper.emit('beforeDestroy'); // Init Flag

        swiper.initialized = false; // Detach events

        swiper.detachEvents(); // Destroy loop

        if (params.loop) {
          swiper.loopDestroy();
        } // Cleanup styles


        if (cleanStyles) {
          swiper.removeClasses();
          $el.removeAttr('style');
          $wrapperEl.removeAttr('style');

          if (slides && slides.length) {
            slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
          }
        }

        swiper.emit('destroy'); // Detach emitter events

        Object.keys(swiper.eventsListeners).forEach(eventName => {
          swiper.off(eventName);
        });

        if (deleteInstance !== false) {
          swiper.$el[0].swiper = null;
          deleteProps(swiper);
        }

        swiper.destroyed = true;
        return null;
      }

      static extendDefaults(newDefaults) {
        extend(extendedDefaults, newDefaults);
      }

      static get extendedDefaults() {
        return extendedDefaults;
      }

      static get defaults() {
        return defaults;
      }

      static installModule(mod) {
        if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
        const modules = Swiper.prototype.__modules__;

        if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
          modules.push(mod);
        }
      }

      static use(module) {
        if (Array.isArray(module)) {
          module.forEach(m => Swiper.installModule(m));
          return Swiper;
        }

        Swiper.installModule(module);
        return Swiper;
      }

    }

    Object.keys(prototypes).forEach(prototypeGroup => {
      Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
      });
    });
    Swiper.use([Resize, Observer]);

    function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
      const document = getDocument();

      if (swiper.params.createElements) {
        Object.keys(checkProps).forEach(key => {
          if (!params[key] && params.auto === true) {
            let element = swiper.$el.children(`.${checkProps[key]}`)[0];

            if (!element) {
              element = document.createElement('div');
              element.className = checkProps[key];
              swiper.$el.append(element);
            }

            params[key] = element;
            originalParams[key] = element;
          }
        });
      }

      return params;
    }

    function Navigation({
      swiper,
      extendParams,
      on,
      emit
    }) {
      extendParams({
        navigation: {
          nextEl: null,
          prevEl: null,
          hideOnClick: false,
          disabledClass: 'swiper-button-disabled',
          hiddenClass: 'swiper-button-hidden',
          lockClass: 'swiper-button-lock'
        }
      });
      swiper.navigation = {
        nextEl: null,
        $nextEl: null,
        prevEl: null,
        $prevEl: null
      };

      function getEl(el) {
        let $el;

        if (el) {
          $el = $(el);

          if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {
            $el = swiper.$el.find(el);
          }
        }

        return $el;
      }

      function toggleEl($el, disabled) {
        const params = swiper.params.navigation;

        if ($el && $el.length > 0) {
          $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);
          if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;

          if (swiper.params.watchOverflow && swiper.enabled) {
            $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
          }
        }
      }

      function update() {
        // Update Navigation Buttons
        if (swiper.params.loop) return;
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;
        toggleEl($prevEl, swiper.isBeginning);
        toggleEl($nextEl, swiper.isEnd);
      }

      function onPrevClick(e) {
        e.preventDefault();
        if (swiper.isBeginning && !swiper.params.loop) return;
        swiper.slidePrev();
      }

      function onNextClick(e) {
        e.preventDefault();
        if (swiper.isEnd && !swiper.params.loop) return;
        swiper.slideNext();
      }

      function init() {
        const params = swiper.params.navigation;
        swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
          nextEl: 'swiper-button-next',
          prevEl: 'swiper-button-prev'
        });
        if (!(params.nextEl || params.prevEl)) return;
        const $nextEl = getEl(params.nextEl);
        const $prevEl = getEl(params.prevEl);

        if ($nextEl && $nextEl.length > 0) {
          $nextEl.on('click', onNextClick);
        }

        if ($prevEl && $prevEl.length > 0) {
          $prevEl.on('click', onPrevClick);
        }

        Object.assign(swiper.navigation, {
          $nextEl,
          nextEl: $nextEl && $nextEl[0],
          $prevEl,
          prevEl: $prevEl && $prevEl[0]
        });

        if (!swiper.enabled) {
          if ($nextEl) $nextEl.addClass(params.lockClass);
          if ($prevEl) $prevEl.addClass(params.lockClass);
        }
      }

      function destroy() {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;

        if ($nextEl && $nextEl.length) {
          $nextEl.off('click', onNextClick);
          $nextEl.removeClass(swiper.params.navigation.disabledClass);
        }

        if ($prevEl && $prevEl.length) {
          $prevEl.off('click', onPrevClick);
          $prevEl.removeClass(swiper.params.navigation.disabledClass);
        }
      }

      on('init', () => {
        init();
        update();
      });
      on('toEdge fromEdge lock unlock', () => {
        update();
      });
      on('destroy', () => {
        destroy();
      });
      on('enable disable', () => {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;

        if ($nextEl) {
          $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
        }

        if ($prevEl) {
          $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);
        }
      });
      on('click', (_s, e) => {
        const {
          $nextEl,
          $prevEl
        } = swiper.navigation;
        const targetEl = e.target;

        if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {
          if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
          let isHidden;

          if ($nextEl) {
            isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
          } else if ($prevEl) {
            isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
          }

          if (isHidden === true) {
            emit('navigationShow');
          } else {
            emit('navigationHide');
          }

          if ($nextEl) {
            $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
          }

          if ($prevEl) {
            $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
        }
      });
      Object.assign(swiper.navigation, {
        update,
        init,
        destroy
      });
    }

    function classesToSelector(classes = '') {
      return `.${classes.trim().replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
    }

    function Pagination({
      swiper,
      extendParams,
      on,
      emit
    }) {
      const pfx = 'swiper-pagination';
      extendParams({
        pagination: {
          el: null,
          bulletElement: 'span',
          clickable: false,
          hideOnClick: false,
          renderBullet: null,
          renderProgressbar: null,
          renderFraction: null,
          renderCustom: null,
          progressbarOpposite: false,
          type: 'bullets',
          // 'bullets' or 'progressbar' or 'fraction' or 'custom'
          dynamicBullets: false,
          dynamicMainBullets: 1,
          formatFractionCurrent: number => number,
          formatFractionTotal: number => number,
          bulletClass: `${pfx}-bullet`,
          bulletActiveClass: `${pfx}-bullet-active`,
          modifierClass: `${pfx}-`,
          currentClass: `${pfx}-current`,
          totalClass: `${pfx}-total`,
          hiddenClass: `${pfx}-hidden`,
          progressbarFillClass: `${pfx}-progressbar-fill`,
          progressbarOppositeClass: `${pfx}-progressbar-opposite`,
          clickableClass: `${pfx}-clickable`,
          lockClass: `${pfx}-lock`,
          horizontalClass: `${pfx}-horizontal`,
          verticalClass: `${pfx}-vertical`
        }
      });
      swiper.pagination = {
        el: null,
        $el: null,
        bullets: []
      };
      let bulletSize;
      let dynamicBulletIndex = 0;

      function isPaginationDisabled() {
        return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
      }

      function setSideBullets($bulletEl, position) {
        const {
          bulletActiveClass
        } = swiper.params.pagination;
        $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
      }

      function update() {
        // Render || Update Pagination bullets/items
        const rtl = swiper.rtl;
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        const $el = swiper.pagination.$el; // Current/Total

        let current;
        const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

        if (swiper.params.loop) {
          current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

          if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
            current -= slidesLength - swiper.loopedSlides * 2;
          }

          if (current > total - 1) current -= total;
          if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
        } else if (typeof swiper.snapIndex !== 'undefined') {
          current = swiper.snapIndex;
        } else {
          current = swiper.activeIndex || 0;
        } // Types


        if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
          const bullets = swiper.pagination.bullets;
          let firstIndex;
          let lastIndex;
          let midIndex;

          if (params.dynamicBullets) {
            bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
            $el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);

            if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
              dynamicBulletIndex += current - swiper.previousIndex;

              if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                dynamicBulletIndex = params.dynamicMainBullets - 1;
              } else if (dynamicBulletIndex < 0) {
                dynamicBulletIndex = 0;
              }
            }

            firstIndex = current - dynamicBulletIndex;
            lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
            midIndex = (lastIndex + firstIndex) / 2;
          }

          bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`).join(' '));

          if ($el.length > 1) {
            bullets.each(bullet => {
              const $bullet = $(bullet);
              const bulletIndex = $bullet.index();

              if (bulletIndex === current) {
                $bullet.addClass(params.bulletActiveClass);
              }

              if (params.dynamicBullets) {
                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                  $bullet.addClass(`${params.bulletActiveClass}-main`);
                }

                if (bulletIndex === firstIndex) {
                  setSideBullets($bullet, 'prev');
                }

                if (bulletIndex === lastIndex) {
                  setSideBullets($bullet, 'next');
                }
              }
            });
          } else {
            const $bullet = bullets.eq(current);
            const bulletIndex = $bullet.index();
            $bullet.addClass(params.bulletActiveClass);

            if (params.dynamicBullets) {
              const $firstDisplayedBullet = bullets.eq(firstIndex);
              const $lastDisplayedBullet = bullets.eq(lastIndex);

              for (let i = firstIndex; i <= lastIndex; i += 1) {
                bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
              }

              if (swiper.params.loop) {
                if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
                  for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                    bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                  }

                  bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
                } else {
                  setSideBullets($firstDisplayedBullet, 'prev');
                  setSideBullets($lastDisplayedBullet, 'next');
                }
              } else {
                setSideBullets($firstDisplayedBullet, 'prev');
                setSideBullets($lastDisplayedBullet, 'next');
              }
            }
          }

          if (params.dynamicBullets) {
            const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
            const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
            const offsetProp = rtl ? 'right' : 'left';
            bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
          }
        }

        if (params.type === 'fraction') {
          $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
          $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
        }

        if (params.type === 'progressbar') {
          let progressbarDirection;

          if (params.progressbarOpposite) {
            progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
          } else {
            progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
          }

          const scale = (current + 1) / total;
          let scaleX = 1;
          let scaleY = 1;

          if (progressbarDirection === 'horizontal') {
            scaleX = scale;
          } else {
            scaleY = scale;
          }

          $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
        }

        if (params.type === 'custom' && params.renderCustom) {
          $el.html(params.renderCustom(swiper, current + 1, total));
          emit('paginationRender', $el[0]);
        } else {
          emit('paginationUpdate', $el[0]);
        }

        if (swiper.params.watchOverflow && swiper.enabled) {
          $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
        }
      }

      function render() {
        // Render Container
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        const $el = swiper.pagination.$el;
        let paginationHTML = '';

        if (params.type === 'bullets') {
          let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

          if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
            numberOfBullets = slidesLength;
          }

          for (let i = 0; i < numberOfBullets; i += 1) {
            if (params.renderBullet) {
              paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
            } else {
              paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
            }
          }

          $el.html(paginationHTML);
          swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
        }

        if (params.type === 'fraction') {
          if (params.renderFraction) {
            paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
          } else {
            paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
          }

          $el.html(paginationHTML);
        }

        if (params.type === 'progressbar') {
          if (params.renderProgressbar) {
            paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
          } else {
            paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
          }

          $el.html(paginationHTML);
        }

        if (params.type !== 'custom') {
          emit('paginationRender', swiper.pagination.$el[0]);
        }
      }

      function init() {
        swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
          el: 'swiper-pagination'
        });
        const params = swiper.params.pagination;
        if (!params.el) return;
        let $el = $(params.el);
        if ($el.length === 0) return;

        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
          $el = swiper.$el.find(params.el); // check if it belongs to another nested Swiper

          if ($el.length > 1) {
            $el = $el.filter(el => {
              if ($(el).parents('.swiper')[0] !== swiper.el) return false;
              return true;
            });
          }
        }

        if (params.type === 'bullets' && params.clickable) {
          $el.addClass(params.clickableClass);
        }

        $el.addClass(params.modifierClass + params.type);
        $el.addClass(params.modifierClass + swiper.params.direction);

        if (params.type === 'bullets' && params.dynamicBullets) {
          $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
          dynamicBulletIndex = 0;

          if (params.dynamicMainBullets < 1) {
            params.dynamicMainBullets = 1;
          }
        }

        if (params.type === 'progressbar' && params.progressbarOpposite) {
          $el.addClass(params.progressbarOppositeClass);
        }

        if (params.clickable) {
          $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
            e.preventDefault();
            let index = $(this).index() * swiper.params.slidesPerGroup;
            if (swiper.params.loop) index += swiper.loopedSlides;
            swiper.slideTo(index);
          });
        }

        Object.assign(swiper.pagination, {
          $el,
          el: $el[0]
        });

        if (!swiper.enabled) {
          $el.addClass(params.lockClass);
        }
      }

      function destroy() {
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const $el = swiper.pagination.$el;
        $el.removeClass(params.hiddenClass);
        $el.removeClass(params.modifierClass + params.type);
        $el.removeClass(params.modifierClass + swiper.params.direction);
        if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

        if (params.clickable) {
          $el.off('click', classesToSelector(params.bulletClass));
        }
      }

      on('init', () => {
        init();
        render();
        update();
      });
      on('activeIndexChange', () => {
        if (swiper.params.loop) {
          update();
        } else if (typeof swiper.snapIndex === 'undefined') {
          update();
        }
      });
      on('snapIndexChange', () => {
        if (!swiper.params.loop) {
          update();
        }
      });
      on('slidesLengthChange', () => {
        if (swiper.params.loop) {
          render();
          update();
        }
      });
      on('snapGridLengthChange', () => {
        if (!swiper.params.loop) {
          render();
          update();
        }
      });
      on('destroy', () => {
        destroy();
      });
      on('enable disable', () => {
        const {
          $el
        } = swiper.pagination;

        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
        }
      });
      on('lock unlock', () => {
        update();
      });
      on('click', (_s, e) => {
        const targetEl = e.target;
        const {
          $el
        } = swiper.pagination;

        if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
          if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
          const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);

          if (isHidden === true) {
            emit('paginationShow');
          } else {
            emit('paginationHide');
          }

          $el.toggleClass(swiper.params.pagination.hiddenClass);
        }
      });
      Object.assign(swiper.pagination, {
        render,
        update,
        init,
        destroy
      });
    }

    function Scrollbar({
      swiper,
      extendParams,
      on,
      emit
    }) {
      const document = getDocument();
      let isTouched = false;
      let timeout = null;
      let dragTimeout = null;
      let dragStartPos;
      let dragSize;
      let trackSize;
      let divider;
      extendParams({
        scrollbar: {
          el: null,
          dragSize: 'auto',
          hide: false,
          draggable: false,
          snapOnRelease: true,
          lockClass: 'swiper-scrollbar-lock',
          dragClass: 'swiper-scrollbar-drag'
        }
      });
      swiper.scrollbar = {
        el: null,
        dragEl: null,
        $el: null,
        $dragEl: null
      };

      function setTranslate() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        const {
          scrollbar,
          rtlTranslate: rtl,
          progress
        } = swiper;
        const {
          $dragEl,
          $el
        } = scrollbar;
        const params = swiper.params.scrollbar;
        let newSize = dragSize;
        let newPos = (trackSize - dragSize) * progress;

        if (rtl) {
          newPos = -newPos;

          if (newPos > 0) {
            newSize = dragSize - newPos;
            newPos = 0;
          } else if (-newPos + dragSize > trackSize) {
            newSize = trackSize + newPos;
          }
        } else if (newPos < 0) {
          newSize = dragSize + newPos;
          newPos = 0;
        } else if (newPos + dragSize > trackSize) {
          newSize = trackSize - newPos;
        }

        if (swiper.isHorizontal()) {
          $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
          $dragEl[0].style.width = `${newSize}px`;
        } else {
          $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
          $dragEl[0].style.height = `${newSize}px`;
        }

        if (params.hide) {
          clearTimeout(timeout);
          $el[0].style.opacity = 1;
          timeout = setTimeout(() => {
            $el[0].style.opacity = 0;
            $el.transition(400);
          }, 1000);
        }
      }

      function setTransition(duration) {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        swiper.scrollbar.$dragEl.transition(duration);
      }

      function updateSize() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        const {
          scrollbar
        } = swiper;
        const {
          $dragEl,
          $el
        } = scrollbar;
        $dragEl[0].style.width = '';
        $dragEl[0].style.height = '';
        trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
        divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));

        if (swiper.params.scrollbar.dragSize === 'auto') {
          dragSize = trackSize * divider;
        } else {
          dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
        }

        if (swiper.isHorizontal()) {
          $dragEl[0].style.width = `${dragSize}px`;
        } else {
          $dragEl[0].style.height = `${dragSize}px`;
        }

        if (divider >= 1) {
          $el[0].style.display = 'none';
        } else {
          $el[0].style.display = '';
        }

        if (swiper.params.scrollbar.hide) {
          $el[0].style.opacity = 0;
        }

        if (swiper.params.watchOverflow && swiper.enabled) {
          scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
        }
      }

      function getPointerPosition(e) {
        if (swiper.isHorizontal()) {
          return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
        }

        return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
      }

      function setDragPosition(e) {
        const {
          scrollbar,
          rtlTranslate: rtl
        } = swiper;
        const {
          $el
        } = scrollbar;
        let positionRatio;
        positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
        positionRatio = Math.max(Math.min(positionRatio, 1), 0);

        if (rtl) {
          positionRatio = 1 - positionRatio;
        }

        const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
        swiper.updateProgress(position);
        swiper.setTranslate(position);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      function onDragStart(e) {
        const params = swiper.params.scrollbar;
        const {
          scrollbar,
          $wrapperEl
        } = swiper;
        const {
          $el,
          $dragEl
        } = scrollbar;
        isTouched = true;
        dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
        e.preventDefault();
        e.stopPropagation();
        $wrapperEl.transition(100);
        $dragEl.transition(100);
        setDragPosition(e);
        clearTimeout(dragTimeout);
        $el.transition(0);

        if (params.hide) {
          $el.css('opacity', 1);
        }

        if (swiper.params.cssMode) {
          swiper.$wrapperEl.css('scroll-snap-type', 'none');
        }

        emit('scrollbarDragStart', e);
      }

      function onDragMove(e) {
        const {
          scrollbar,
          $wrapperEl
        } = swiper;
        const {
          $el,
          $dragEl
        } = scrollbar;
        if (!isTouched) return;
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
        setDragPosition(e);
        $wrapperEl.transition(0);
        $el.transition(0);
        $dragEl.transition(0);
        emit('scrollbarDragMove', e);
      }

      function onDragEnd(e) {
        const params = swiper.params.scrollbar;
        const {
          scrollbar,
          $wrapperEl
        } = swiper;
        const {
          $el
        } = scrollbar;
        if (!isTouched) return;
        isTouched = false;

        if (swiper.params.cssMode) {
          swiper.$wrapperEl.css('scroll-snap-type', '');
          $wrapperEl.transition('');
        }

        if (params.hide) {
          clearTimeout(dragTimeout);
          dragTimeout = nextTick(() => {
            $el.css('opacity', 0);
            $el.transition(400);
          }, 1000);
        }

        emit('scrollbarDragEnd', e);

        if (params.snapOnRelease) {
          swiper.slideToClosest();
        }
      }

      function events(method) {
        const {
          scrollbar,
          touchEventsTouch,
          touchEventsDesktop,
          params,
          support
        } = swiper;
        const $el = scrollbar.$el;
        const target = $el[0];
        const activeListener = support.passiveListener && params.passiveListeners ? {
          passive: false,
          capture: false
        } : false;
        const passiveListener = support.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        if (!target) return;
        const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';

        if (!support.touch) {
          target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
          document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
          document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
        } else {
          target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
          target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
          target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
        }
      }

      function enableDraggable() {
        if (!swiper.params.scrollbar.el) return;
        events('on');
      }

      function disableDraggable() {
        if (!swiper.params.scrollbar.el) return;
        events('off');
      }

      function init() {
        const {
          scrollbar,
          $el: $swiperEl
        } = swiper;
        swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
          el: 'swiper-scrollbar'
        });
        const params = swiper.params.scrollbar;
        if (!params.el) return;
        let $el = $(params.el);

        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
          $el = $swiperEl.find(params.el);
        }

        let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);

        if ($dragEl.length === 0) {
          $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
          $el.append($dragEl);
        }

        Object.assign(scrollbar, {
          $el,
          el: $el[0],
          $dragEl,
          dragEl: $dragEl[0]
        });

        if (params.draggable) {
          enableDraggable();
        }

        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
        }
      }

      function destroy() {
        disableDraggable();
      }

      on('init', () => {
        init();
        updateSize();
        setTranslate();
      });
      on('update resize observerUpdate lock unlock', () => {
        updateSize();
      });
      on('setTranslate', () => {
        setTranslate();
      });
      on('setTransition', (_s, duration) => {
        setTransition(duration);
      });
      on('enable disable', () => {
        const {
          $el
        } = swiper.scrollbar;

        if ($el) {
          $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);
        }
      });
      on('destroy', () => {
        destroy();
      });
      Object.assign(swiper.scrollbar, {
        updateSize,
        setTranslate,
        init,
        destroy
      });
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function Vnode$7(tag, key, attrs, children, text, dom) {
    	return {tag: tag, key: key, attrs: attrs, children: children, text: text, dom: dom, domSize: undefined, state: undefined, events: undefined, instance: undefined}
    }
    Vnode$7.normalize = function(node) {
    	if (Array.isArray(node)) return Vnode$7("[", undefined, undefined, Vnode$7.normalizeChildren(node), undefined, undefined)
    	if (node == null || typeof node === "boolean") return null
    	if (typeof node === "object") return node
    	return Vnode$7("#", undefined, undefined, String(node), undefined, undefined)
    };
    Vnode$7.normalizeChildren = function(input) {
    	var children = [];
    	if (input.length) {
    		var isKeyed = input[0] != null && input[0].key != null;
    		// Note: this is a *very* perf-sensitive check.
    		// Fun fact: merging the loop like this is somehow faster than splitting
    		// it, noticeably so.
    		for (var i = 1; i < input.length; i++) {
    			if ((input[i] != null && input[i].key != null) !== isKeyed) {
    				throw new TypeError("Vnodes must either always have keys or never have keys!")
    			}
    		}
    		for (var i = 0; i < input.length; i++) {
    			children[i] = Vnode$7.normalize(input[i]);
    		}
    	}
    	return children
    };

    var vnode = Vnode$7;

    var Vnode$6 = vnode;

    // Call via `hyperscriptVnode.apply(startOffset, arguments)`
    //
    // The reason I do it this way, forwarding the arguments and passing the start
    // offset in `this`, is so I don't have to create a temporary array in a
    // performance-critical path.
    //
    // In native ES6, I'd instead add a final `...args` parameter to the
    // `hyperscript` and `fragment` factories and define this as
    // `hyperscriptVnode(...args)`, since modern engines do optimize that away. But
    // ES5 (what Mithril requires thanks to IE support) doesn't give me that luxury,
    // and engines aren't nearly intelligent enough to do either of these:
    //
    // 1. Elide the allocation for `[].slice.call(arguments, 1)` when it's passed to
    //    another function only to be indexed.
    // 2. Elide an `arguments` allocation when it's passed to any function other
    //    than `Function.prototype.apply` or `Reflect.apply`.
    //
    // In ES6, it'd probably look closer to this (I'd need to profile it, though):
    // module.exports = function(attrs, ...children) {
    //     if (attrs == null || typeof attrs === "object" && attrs.tag == null && !Array.isArray(attrs)) {
    //         if (children.length === 1 && Array.isArray(children[0])) children = children[0]
    //     } else {
    //         children = children.length === 0 && Array.isArray(attrs) ? attrs : [attrs, ...children]
    //         attrs = undefined
    //     }
    //
    //     if (attrs == null) attrs = {}
    //     return Vnode("", attrs.key, attrs, children)
    // }
    var hyperscriptVnode$2 = function() {
    	var attrs = arguments[this], start = this + 1, children;

    	if (attrs == null) {
    		attrs = {};
    	} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
    		attrs = {};
    		start = this;
    	}

    	if (arguments.length === start + 1) {
    		children = arguments[start];
    		if (!Array.isArray(children)) children = [children];
    	} else {
    		children = [];
    		while (start < arguments.length) children.push(arguments[start++]);
    	}

    	return Vnode$6("", attrs.key, attrs, children)
    };

    var Vnode$5 = vnode;
    var hyperscriptVnode$1 = hyperscriptVnode$2;

    var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g;
    var selectorCache = {};
    var hasOwn = {}.hasOwnProperty;

    function isEmpty(object) {
    	for (var key in object) if (hasOwn.call(object, key)) return false
    	return true
    }

    function compileSelector(selector) {
    	var match, tag = "div", classes = [], attrs = {};
    	while (match = selectorParser.exec(selector)) {
    		var type = match[1], value = match[2];
    		if (type === "" && value !== "") tag = value;
    		else if (type === "#") attrs.id = value;
    		else if (type === ".") classes.push(value);
    		else if (match[3][0] === "[") {
    			var attrValue = match[6];
    			if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\");
    			if (match[4] === "class") classes.push(attrValue);
    			else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true;
    		}
    	}
    	if (classes.length > 0) attrs.className = classes.join(" ");
    	return selectorCache[selector] = {tag: tag, attrs: attrs}
    }

    function execSelector(state, vnode) {
    	var attrs = vnode.attrs;
    	var children = Vnode$5.normalizeChildren(vnode.children);
    	var hasClass = hasOwn.call(attrs, "class");
    	var className = hasClass ? attrs.class : attrs.className;

    	vnode.tag = state.tag;
    	vnode.attrs = null;
    	vnode.children = undefined;

    	if (!isEmpty(state.attrs) && !isEmpty(attrs)) {
    		var newAttrs = {};

    		for (var key in attrs) {
    			if (hasOwn.call(attrs, key)) newAttrs[key] = attrs[key];
    		}

    		attrs = newAttrs;
    	}

    	for (var key in state.attrs) {
    		if (hasOwn.call(state.attrs, key) && key !== "className" && !hasOwn.call(attrs, key)){
    			attrs[key] = state.attrs[key];
    		}
    	}
    	if (className != null || state.attrs.className != null) attrs.className =
    		className != null
    			? state.attrs.className != null
    				? String(state.attrs.className) + " " + String(className)
    				: className
    			: state.attrs.className != null
    				? state.attrs.className
    				: null;

    	if (hasClass) attrs.class = null;

    	for (var key in attrs) {
    		if (hasOwn.call(attrs, key) && key !== "key") {
    			vnode.attrs = attrs;
    			break
    		}
    	}

    	if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
    		vnode.text = children[0].children;
    	} else {
    		vnode.children = children;
    	}

    	return vnode
    }

    function hyperscript$2(selector) {
    	if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
    		throw Error("The selector must be either a string or a component.");
    	}

    	var vnode = hyperscriptVnode$1.apply(1, arguments);

    	if (typeof selector === "string") {
    		vnode.children = Vnode$5.normalizeChildren(vnode.children);
    		if (selector !== "[") return execSelector(selectorCache[selector] || compileSelector(selector), vnode)
    	}

    	vnode.tag = selector;
    	return vnode
    }

    var hyperscript_1$1 = hyperscript$2;

    var Vnode$4 = vnode;

    var trust = function(html) {
    	if (html == null) html = "";
    	return Vnode$4("<", undefined, undefined, html, undefined, undefined)
    };

    var Vnode$3 = vnode;
    var hyperscriptVnode = hyperscriptVnode$2;

    var fragment = function() {
    	var vnode = hyperscriptVnode.apply(0, arguments);

    	vnode.tag = "[";
    	vnode.children = Vnode$3.normalizeChildren(vnode.children);
    	return vnode
    };

    var hyperscript$1 = hyperscript_1$1;

    hyperscript$1.trust = trust;
    hyperscript$1.fragment = fragment;

    var hyperscript_1 = hyperscript$1;

    var promise = {exports: {}};

    /** @constructor */
    var PromisePolyfill$2 = function(executor) {
    	if (!(this instanceof PromisePolyfill$2)) throw new Error("Promise must be called with `new`")
    	if (typeof executor !== "function") throw new TypeError("executor must be a function")

    	var self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false);
    	var instance = self._instance = {resolvers: resolvers, rejectors: rejectors};
    	var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout;
    	function handler(list, shouldAbsorb) {
    		return function execute(value) {
    			var then;
    			try {
    				if (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
    					if (value === self) throw new TypeError("Promise can't be resolved w/ itself")
    					executeOnce(then.bind(value));
    				}
    				else {
    					callAsync(function() {
    						if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value);
    						for (var i = 0; i < list.length; i++) list[i](value);
    						resolvers.length = 0, rejectors.length = 0;
    						instance.state = shouldAbsorb;
    						instance.retry = function() {execute(value);};
    					});
    				}
    			}
    			catch (e) {
    				rejectCurrent(e);
    			}
    		}
    	}
    	function executeOnce(then) {
    		var runs = 0;
    		function run(fn) {
    			return function(value) {
    				if (runs++ > 0) return
    				fn(value);
    			}
    		}
    		var onerror = run(rejectCurrent);
    		try {then(run(resolveCurrent), onerror);} catch (e) {onerror(e);}
    	}

    	executeOnce(executor);
    };
    PromisePolyfill$2.prototype.then = function(onFulfilled, onRejection) {
    	var self = this, instance = self._instance;
    	function handle(callback, list, next, state) {
    		list.push(function(value) {
    			if (typeof callback !== "function") next(value);
    			else try {resolveNext(callback(value));} catch (e) {if (rejectNext) rejectNext(e);}
    		});
    		if (typeof instance.retry === "function" && state === instance.state) instance.retry();
    	}
    	var resolveNext, rejectNext;
    	var promise = new PromisePolyfill$2(function(resolve, reject) {resolveNext = resolve, rejectNext = reject;});
    	handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false);
    	return promise
    };
    PromisePolyfill$2.prototype.catch = function(onRejection) {
    	return this.then(null, onRejection)
    };
    PromisePolyfill$2.prototype.finally = function(callback) {
    	return this.then(
    		function(value) {
    			return PromisePolyfill$2.resolve(callback()).then(function() {
    				return value
    			})
    		},
    		function(reason) {
    			return PromisePolyfill$2.resolve(callback()).then(function() {
    				return PromisePolyfill$2.reject(reason);
    			})
    		}
    	)
    };
    PromisePolyfill$2.resolve = function(value) {
    	if (value instanceof PromisePolyfill$2) return value
    	return new PromisePolyfill$2(function(resolve) {resolve(value);})
    };
    PromisePolyfill$2.reject = function(value) {
    	return new PromisePolyfill$2(function(resolve, reject) {reject(value);})
    };
    PromisePolyfill$2.all = function(list) {
    	return new PromisePolyfill$2(function(resolve, reject) {
    		var total = list.length, count = 0, values = [];
    		if (list.length === 0) resolve([]);
    		else for (var i = 0; i < list.length; i++) {
    			(function(i) {
    				function consume(value) {
    					count++;
    					values[i] = value;
    					if (count === total) resolve(values);
    				}
    				if (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
    					list[i].then(consume, reject);
    				}
    				else consume(list[i]);
    			})(i);
    		}
    	})
    };
    PromisePolyfill$2.race = function(list) {
    	return new PromisePolyfill$2(function(resolve, reject) {
    		for (var i = 0; i < list.length; i++) {
    			list[i].then(resolve, reject);
    		}
    	})
    };

    var polyfill = PromisePolyfill$2;

    var PromisePolyfill$1 = polyfill;

    if (typeof window !== "undefined") {
    	if (typeof window.Promise === "undefined") {
    		window.Promise = PromisePolyfill$1;
    	} else if (!window.Promise.prototype.finally) {
    		window.Promise.prototype.finally = PromisePolyfill$1.prototype.finally;
    	}
    	promise.exports = window.Promise;
    } else if (typeof commonjsGlobal !== "undefined") {
    	if (typeof commonjsGlobal.Promise === "undefined") {
    		commonjsGlobal.Promise = PromisePolyfill$1;
    	} else if (!commonjsGlobal.Promise.prototype.finally) {
    		commonjsGlobal.Promise.prototype.finally = PromisePolyfill$1.prototype.finally;
    	}
    	promise.exports = commonjsGlobal.Promise;
    } else {
    	promise.exports = PromisePolyfill$1;
    }

    var Vnode$2 = vnode;

    var render$2 = function($window) {
    	var $doc = $window && $window.document;
    	var currentRedraw;

    	var nameSpace = {
    		svg: "http://www.w3.org/2000/svg",
    		math: "http://www.w3.org/1998/Math/MathML"
    	};

    	function getNameSpace(vnode) {
    		return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]
    	}

    	//sanity check to discourage people from doing `vnode.state = ...`
    	function checkState(vnode, original) {
    		if (vnode.state !== original) throw new Error("`vnode.state` must not be modified")
    	}

    	//Note: the hook is passed as the `this` argument to allow proxying the
    	//arguments without requiring a full array allocation to do so. It also
    	//takes advantage of the fact the current `vnode` is the first argument in
    	//all lifecycle methods.
    	function callHook(vnode) {
    		var original = vnode.state;
    		try {
    			return this.apply(original, arguments)
    		} finally {
    			checkState(vnode, original);
    		}
    	}

    	// IE11 (at least) throws an UnspecifiedError when accessing document.activeElement when
    	// inside an iframe. Catch and swallow this error, and heavy-handidly return null.
    	function activeElement() {
    		try {
    			return $doc.activeElement
    		} catch (e) {
    			return null
    		}
    	}
    	//create
    	function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
    		for (var i = start; i < end; i++) {
    			var vnode = vnodes[i];
    			if (vnode != null) {
    				createNode(parent, vnode, hooks, ns, nextSibling);
    			}
    		}
    	}
    	function createNode(parent, vnode, hooks, ns, nextSibling) {
    		var tag = vnode.tag;
    		if (typeof tag === "string") {
    			vnode.state = {};
    			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
    			switch (tag) {
    				case "#": createText(parent, vnode, nextSibling); break
    				case "<": createHTML(parent, vnode, ns, nextSibling); break
    				case "[": createFragment(parent, vnode, hooks, ns, nextSibling); break
    				default: createElement(parent, vnode, hooks, ns, nextSibling);
    			}
    		}
    		else createComponent(parent, vnode, hooks, ns, nextSibling);
    	}
    	function createText(parent, vnode, nextSibling) {
    		vnode.dom = $doc.createTextNode(vnode.children);
    		insertNode(parent, vnode.dom, nextSibling);
    	}
    	var possibleParents = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"};
    	function createHTML(parent, vnode, ns, nextSibling) {
    		var match = vnode.children.match(/^\s*?<(\w+)/im) || [];
    		// not using the proper parent makes the child element(s) vanish.
    		//     var div = document.createElement("div")
    		//     div.innerHTML = "<td>i</td><td>j</td>"
    		//     console.log(div.innerHTML)
    		// --> "ij", no <td> in sight.
    		var temp = $doc.createElement(possibleParents[match[1]] || "div");
    		if (ns === "http://www.w3.org/2000/svg") {
    			temp.innerHTML = "<svg xmlns=\"http://www.w3.org/2000/svg\">" + vnode.children + "</svg>";
    			temp = temp.firstChild;
    		} else {
    			temp.innerHTML = vnode.children;
    		}
    		vnode.dom = temp.firstChild;
    		vnode.domSize = temp.childNodes.length;
    		// Capture nodes to remove, so we don't confuse them.
    		vnode.instance = [];
    		var fragment = $doc.createDocumentFragment();
    		var child;
    		while (child = temp.firstChild) {
    			vnode.instance.push(child);
    			fragment.appendChild(child);
    		}
    		insertNode(parent, fragment, nextSibling);
    	}
    	function createFragment(parent, vnode, hooks, ns, nextSibling) {
    		var fragment = $doc.createDocumentFragment();
    		if (vnode.children != null) {
    			var children = vnode.children;
    			createNodes(fragment, children, 0, children.length, hooks, null, ns);
    		}
    		vnode.dom = fragment.firstChild;
    		vnode.domSize = fragment.childNodes.length;
    		insertNode(parent, fragment, nextSibling);
    	}
    	function createElement(parent, vnode, hooks, ns, nextSibling) {
    		var tag = vnode.tag;
    		var attrs = vnode.attrs;
    		var is = attrs && attrs.is;

    		ns = getNameSpace(vnode) || ns;

    		var element = ns ?
    			is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
    			is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag);
    		vnode.dom = element;

    		if (attrs != null) {
    			setAttrs(vnode, attrs, ns);
    		}

    		insertNode(parent, element, nextSibling);

    		if (!maybeSetContentEditable(vnode)) {
    			if (vnode.text != null) {
    				if (vnode.text !== "") element.textContent = vnode.text;
    				else vnode.children = [Vnode$2("#", undefined, undefined, vnode.text, undefined, undefined)];
    			}
    			if (vnode.children != null) {
    				var children = vnode.children;
    				createNodes(element, children, 0, children.length, hooks, null, ns);
    				if (vnode.tag === "select" && attrs != null) setLateSelectAttrs(vnode, attrs);
    			}
    		}
    	}
    	function initComponent(vnode, hooks) {
    		var sentinel;
    		if (typeof vnode.tag.view === "function") {
    			vnode.state = Object.create(vnode.tag);
    			sentinel = vnode.state.view;
    			if (sentinel.$$reentrantLock$$ != null) return
    			sentinel.$$reentrantLock$$ = true;
    		} else {
    			vnode.state = void 0;
    			sentinel = vnode.tag;
    			if (sentinel.$$reentrantLock$$ != null) return
    			sentinel.$$reentrantLock$$ = true;
    			vnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode);
    		}
    		initLifecycle(vnode.state, vnode, hooks);
    		if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks);
    		vnode.instance = Vnode$2.normalize(callHook.call(vnode.state.view, vnode));
    		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
    		sentinel.$$reentrantLock$$ = null;
    	}
    	function createComponent(parent, vnode, hooks, ns, nextSibling) {
    		initComponent(vnode, hooks);
    		if (vnode.instance != null) {
    			createNode(parent, vnode.instance, hooks, ns, nextSibling);
    			vnode.dom = vnode.instance.dom;
    			vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0;
    		}
    		else {
    			vnode.domSize = 0;
    		}
    	}

    	//update
    	/**
    	 * @param {Element|Fragment} parent - the parent element
    	 * @param {Vnode[] | null} old - the list of vnodes of the last `render()` call for
    	 *                               this part of the tree
    	 * @param {Vnode[] | null} vnodes - as above, but for the current `render()` call.
    	 * @param {Function[]} hooks - an accumulator of post-render hooks (oncreate/onupdate)
    	 * @param {Element | null} nextSibling - the next DOM node if we're dealing with a
    	 *                                       fragment that is not the last item in its
    	 *                                       parent
    	 * @param {'svg' | 'math' | String | null} ns) - the current XML namespace, if any
    	 * @returns void
    	 */
    	// This function diffs and patches lists of vnodes, both keyed and unkeyed.
    	//
    	// We will:
    	//
    	// 1. describe its general structure
    	// 2. focus on the diff algorithm optimizations
    	// 3. discuss DOM node operations.

    	// ## Overview:
    	//
    	// The updateNodes() function:
    	// - deals with trivial cases
    	// - determines whether the lists are keyed or unkeyed based on the first non-null node
    	//   of each list.
    	// - diffs them and patches the DOM if needed (that's the brunt of the code)
    	// - manages the leftovers: after diffing, are there:
    	//   - old nodes left to remove?
    	// 	 - new nodes to insert?
    	// 	 deal with them!
    	//
    	// The lists are only iterated over once, with an exception for the nodes in `old` that
    	// are visited in the fourth part of the diff and in the `removeNodes` loop.

    	// ## Diffing
    	//
    	// Reading https://github.com/localvoid/ivi/blob/ddc09d06abaef45248e6133f7040d00d3c6be853/packages/ivi/src/vdom/implementation.ts#L617-L837
    	// may be good for context on longest increasing subsequence-based logic for moving nodes.
    	//
    	// In order to diff keyed lists, one has to
    	//
    	// 1) match nodes in both lists, per key, and update them accordingly
    	// 2) create the nodes present in the new list, but absent in the old one
    	// 3) remove the nodes present in the old list, but absent in the new one
    	// 4) figure out what nodes in 1) to move in order to minimize the DOM operations.
    	//
    	// To achieve 1) one can create a dictionary of keys => index (for the old list), then iterate
    	// over the new list and for each new vnode, find the corresponding vnode in the old list using
    	// the map.
    	// 2) is achieved in the same step: if a new node has no corresponding entry in the map, it is new
    	// and must be created.
    	// For the removals, we actually remove the nodes that have been updated from the old list.
    	// The nodes that remain in that list after 1) and 2) have been performed can be safely removed.
    	// The fourth step is a bit more complex and relies on the longest increasing subsequence (LIS)
    	// algorithm.
    	//
    	// the longest increasing subsequence is the list of nodes that can remain in place. Imagine going
    	// from `1,2,3,4,5` to `4,5,1,2,3` where the numbers are not necessarily the keys, but the indices
    	// corresponding to the keyed nodes in the old list (keyed nodes `e,d,c,b,a` => `b,a,e,d,c` would
    	//  match the above lists, for example).
    	//
    	// In there are two increasing subsequences: `4,5` and `1,2,3`, the latter being the longest. We
    	// can update those nodes without moving them, and only call `insertNode` on `4` and `5`.
    	//
    	// @localvoid adapted the algo to also support node deletions and insertions (the `lis` is actually
    	// the longest increasing subsequence *of old nodes still present in the new list*).
    	//
    	// It is a general algorithm that is fireproof in all circumstances, but it requires the allocation
    	// and the construction of a `key => oldIndex` map, and three arrays (one with `newIndex => oldIndex`,
    	// the `LIS` and a temporary one to create the LIS).
    	//
    	// So we cheat where we can: if the tails of the lists are identical, they are guaranteed to be part of
    	// the LIS and can be updated without moving them.
    	//
    	// If two nodes are swapped, they are guaranteed not to be part of the LIS, and must be moved (with
    	// the exception of the last node if the list is fully reversed).
    	//
    	// ## Finding the next sibling.
    	//
    	// `updateNode()` and `createNode()` expect a nextSibling parameter to perform DOM operations.
    	// When the list is being traversed top-down, at any index, the DOM nodes up to the previous
    	// vnode reflect the content of the new list, whereas the rest of the DOM nodes reflect the old
    	// list. The next sibling must be looked for in the old list using `getNextSibling(... oldStart + 1 ...)`.
    	//
    	// In the other scenarios (swaps, upwards traversal, map-based diff),
    	// the new vnodes list is traversed upwards. The DOM nodes at the bottom of the list reflect the
    	// bottom part of the new vnodes list, and we can use the `v.dom`  value of the previous node
    	// as the next sibling (cached in the `nextSibling` variable).


    	// ## DOM node moves
    	//
    	// In most scenarios `updateNode()` and `createNode()` perform the DOM operations. However,
    	// this is not the case if the node moved (second and fourth part of the diff algo). We move
    	// the old DOM nodes before updateNode runs because it enables us to use the cached `nextSibling`
    	// variable rather than fetching it using `getNextSibling()`.
    	//
    	// The fourth part of the diff currently inserts nodes unconditionally, leading to issues
    	// like #1791 and #1999. We need to be smarter about those situations where adjascent old
    	// nodes remain together in the new list in a way that isn't covered by parts one and
    	// three of the diff algo.

    	function updateNodes(parent, old, vnodes, hooks, nextSibling, ns) {
    		if (old === vnodes || old == null && vnodes == null) return
    		else if (old == null || old.length === 0) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns);
    		else if (vnodes == null || vnodes.length === 0) removeNodes(parent, old, 0, old.length);
    		else {
    			var isOldKeyed = old[0] != null && old[0].key != null;
    			var isKeyed = vnodes[0] != null && vnodes[0].key != null;
    			var start = 0, oldStart = 0;
    			if (!isOldKeyed) while (oldStart < old.length && old[oldStart] == null) oldStart++;
    			if (!isKeyed) while (start < vnodes.length && vnodes[start] == null) start++;
    			if (isKeyed === null && isOldKeyed == null) return // both lists are full of nulls
    			if (isOldKeyed !== isKeyed) {
    				removeNodes(parent, old, oldStart, old.length);
    				createNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns);
    			} else if (!isKeyed) {
    				// Don't index past the end of either list (causes deopts).
    				var commonLength = old.length < vnodes.length ? old.length : vnodes.length;
    				// Rewind if necessary to the first non-null index on either side.
    				// We could alternatively either explicitly create or remove nodes when `start !== oldStart`
    				// but that would be optimizing for sparse lists which are more rare than dense ones.
    				start = start < oldStart ? start : oldStart;
    				for (; start < commonLength; start++) {
    					o = old[start];
    					v = vnodes[start];
    					if (o === v || o == null && v == null) continue
    					else if (o == null) createNode(parent, v, hooks, ns, getNextSibling(old, start + 1, nextSibling));
    					else if (v == null) removeNode(parent, o);
    					else updateNode(parent, o, v, hooks, getNextSibling(old, start + 1, nextSibling), ns);
    				}
    				if (old.length > commonLength) removeNodes(parent, old, start, old.length);
    				if (vnodes.length > commonLength) createNodes(parent, vnodes, start, vnodes.length, hooks, nextSibling, ns);
    			} else {
    				// keyed diff
    				var oldEnd = old.length - 1, end = vnodes.length - 1, map, o, v, oe, ve, topSibling;

    				// bottom-up
    				while (oldEnd >= oldStart && end >= start) {
    					oe = old[oldEnd];
    					ve = vnodes[end];
    					if (oe.key !== ve.key) break
    					if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns);
    					if (ve.dom != null) nextSibling = ve.dom;
    					oldEnd--, end--;
    				}
    				// top-down
    				while (oldEnd >= oldStart && end >= start) {
    					o = old[oldStart];
    					v = vnodes[start];
    					if (o.key !== v.key) break
    					oldStart++, start++;
    					if (o !== v) updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), ns);
    				}
    				// swaps and list reversals
    				while (oldEnd >= oldStart && end >= start) {
    					if (start === end) break
    					if (o.key !== ve.key || oe.key !== v.key) break
    					topSibling = getNextSibling(old, oldStart, nextSibling);
    					moveNodes(parent, oe, topSibling);
    					if (oe !== v) updateNode(parent, oe, v, hooks, topSibling, ns);
    					if (++start <= --end) moveNodes(parent, o, nextSibling);
    					if (o !== ve) updateNode(parent, o, ve, hooks, nextSibling, ns);
    					if (ve.dom != null) nextSibling = ve.dom;
    					oldStart++; oldEnd--;
    					oe = old[oldEnd];
    					ve = vnodes[end];
    					o = old[oldStart];
    					v = vnodes[start];
    				}
    				// bottom up once again
    				while (oldEnd >= oldStart && end >= start) {
    					if (oe.key !== ve.key) break
    					if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns);
    					if (ve.dom != null) nextSibling = ve.dom;
    					oldEnd--, end--;
    					oe = old[oldEnd];
    					ve = vnodes[end];
    				}
    				if (start > end) removeNodes(parent, old, oldStart, oldEnd + 1);
    				else if (oldStart > oldEnd) createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);
    				else {
    					// inspired by ivi https://github.com/ivijs/ivi/ by Boris Kaul
    					var originalNextSibling = nextSibling, vnodesLength = end - start + 1, oldIndices = new Array(vnodesLength), li=0, i=0, pos = 2147483647, matched = 0, map, lisIndices;
    					for (i = 0; i < vnodesLength; i++) oldIndices[i] = -1;
    					for (i = end; i >= start; i--) {
    						if (map == null) map = getKeyMap(old, oldStart, oldEnd + 1);
    						ve = vnodes[i];
    						var oldIndex = map[ve.key];
    						if (oldIndex != null) {
    							pos = (oldIndex < pos) ? oldIndex : -1; // becomes -1 if nodes were re-ordered
    							oldIndices[i-start] = oldIndex;
    							oe = old[oldIndex];
    							old[oldIndex] = null;
    							if (oe !== ve) updateNode(parent, oe, ve, hooks, nextSibling, ns);
    							if (ve.dom != null) nextSibling = ve.dom;
    							matched++;
    						}
    					}
    					nextSibling = originalNextSibling;
    					if (matched !== oldEnd - oldStart + 1) removeNodes(parent, old, oldStart, oldEnd + 1);
    					if (matched === 0) createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns);
    					else {
    						if (pos === -1) {
    							// the indices of the indices of the items that are part of the
    							// longest increasing subsequence in the oldIndices list
    							lisIndices = makeLisIndices(oldIndices);
    							li = lisIndices.length - 1;
    							for (i = end; i >= start; i--) {
    								v = vnodes[i];
    								if (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling);
    								else {
    									if (lisIndices[li] === i - start) li--;
    									else moveNodes(parent, v, nextSibling);
    								}
    								if (v.dom != null) nextSibling = vnodes[i].dom;
    							}
    						} else {
    							for (i = end; i >= start; i--) {
    								v = vnodes[i];
    								if (oldIndices[i-start] === -1) createNode(parent, v, hooks, ns, nextSibling);
    								if (v.dom != null) nextSibling = vnodes[i].dom;
    							}
    						}
    					}
    				}
    			}
    		}
    	}
    	function updateNode(parent, old, vnode, hooks, nextSibling, ns) {
    		var oldTag = old.tag, tag = vnode.tag;
    		if (oldTag === tag) {
    			vnode.state = old.state;
    			vnode.events = old.events;
    			if (shouldNotUpdate(vnode, old)) return
    			if (typeof oldTag === "string") {
    				if (vnode.attrs != null) {
    					updateLifecycle(vnode.attrs, vnode, hooks);
    				}
    				switch (oldTag) {
    					case "#": updateText(old, vnode); break
    					case "<": updateHTML(parent, old, vnode, ns, nextSibling); break
    					case "[": updateFragment(parent, old, vnode, hooks, nextSibling, ns); break
    					default: updateElement(old, vnode, hooks, ns);
    				}
    			}
    			else updateComponent(parent, old, vnode, hooks, nextSibling, ns);
    		}
    		else {
    			removeNode(parent, old);
    			createNode(parent, vnode, hooks, ns, nextSibling);
    		}
    	}
    	function updateText(old, vnode) {
    		if (old.children.toString() !== vnode.children.toString()) {
    			old.dom.nodeValue = vnode.children;
    		}
    		vnode.dom = old.dom;
    	}
    	function updateHTML(parent, old, vnode, ns, nextSibling) {
    		if (old.children !== vnode.children) {
    			removeHTML(parent, old);
    			createHTML(parent, vnode, ns, nextSibling);
    		}
    		else {
    			vnode.dom = old.dom;
    			vnode.domSize = old.domSize;
    			vnode.instance = old.instance;
    		}
    	}
    	function updateFragment(parent, old, vnode, hooks, nextSibling, ns) {
    		updateNodes(parent, old.children, vnode.children, hooks, nextSibling, ns);
    		var domSize = 0, children = vnode.children;
    		vnode.dom = null;
    		if (children != null) {
    			for (var i = 0; i < children.length; i++) {
    				var child = children[i];
    				if (child != null && child.dom != null) {
    					if (vnode.dom == null) vnode.dom = child.dom;
    					domSize += child.domSize || 1;
    				}
    			}
    			if (domSize !== 1) vnode.domSize = domSize;
    		}
    	}
    	function updateElement(old, vnode, hooks, ns) {
    		var element = vnode.dom = old.dom;
    		ns = getNameSpace(vnode) || ns;

    		if (vnode.tag === "textarea") {
    			if (vnode.attrs == null) vnode.attrs = {};
    			if (vnode.text != null) {
    				vnode.attrs.value = vnode.text; //FIXME handle multiple children
    				vnode.text = undefined;
    			}
    		}
    		updateAttrs(vnode, old.attrs, vnode.attrs, ns);
    		if (!maybeSetContentEditable(vnode)) {
    			if (old.text != null && vnode.text != null && vnode.text !== "") {
    				if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text;
    			}
    			else {
    				if (old.text != null) old.children = [Vnode$2("#", undefined, undefined, old.text, undefined, old.dom.firstChild)];
    				if (vnode.text != null) vnode.children = [Vnode$2("#", undefined, undefined, vnode.text, undefined, undefined)];
    				updateNodes(element, old.children, vnode.children, hooks, null, ns);
    			}
    		}
    	}
    	function updateComponent(parent, old, vnode, hooks, nextSibling, ns) {
    		vnode.instance = Vnode$2.normalize(callHook.call(vnode.state.view, vnode));
    		if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
    		updateLifecycle(vnode.state, vnode, hooks);
    		if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks);
    		if (vnode.instance != null) {
    			if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling);
    			else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, ns);
    			vnode.dom = vnode.instance.dom;
    			vnode.domSize = vnode.instance.domSize;
    		}
    		else if (old.instance != null) {
    			removeNode(parent, old.instance);
    			vnode.dom = undefined;
    			vnode.domSize = 0;
    		}
    		else {
    			vnode.dom = old.dom;
    			vnode.domSize = old.domSize;
    		}
    	}
    	function getKeyMap(vnodes, start, end) {
    		var map = Object.create(null);
    		for (; start < end; start++) {
    			var vnode = vnodes[start];
    			if (vnode != null) {
    				var key = vnode.key;
    				if (key != null) map[key] = start;
    			}
    		}
    		return map
    	}
    	// Lifted from ivi https://github.com/ivijs/ivi/
    	// takes a list of unique numbers (-1 is special and can
    	// occur multiple times) and returns an array with the indices
    	// of the items that are part of the longest increasing
    	// subsequece
    	var lisTemp = [];
    	function makeLisIndices(a) {
    		var result = [0];
    		var u = 0, v = 0, i = 0;
    		var il = lisTemp.length = a.length;
    		for (var i = 0; i < il; i++) lisTemp[i] = a[i];
    		for (var i = 0; i < il; ++i) {
    			if (a[i] === -1) continue
    			var j = result[result.length - 1];
    			if (a[j] < a[i]) {
    				lisTemp[i] = j;
    				result.push(i);
    				continue
    			}
    			u = 0;
    			v = result.length - 1;
    			while (u < v) {
    				// Fast integer average without overflow.
    				// eslint-disable-next-line no-bitwise
    				var c = (u >>> 1) + (v >>> 1) + (u & v & 1);
    				if (a[result[c]] < a[i]) {
    					u = c + 1;
    				}
    				else {
    					v = c;
    				}
    			}
    			if (a[i] < a[result[u]]) {
    				if (u > 0) lisTemp[i] = result[u - 1];
    				result[u] = i;
    			}
    		}
    		u = result.length;
    		v = result[u - 1];
    		while (u-- > 0) {
    			result[u] = v;
    			v = lisTemp[v];
    		}
    		lisTemp.length = 0;
    		return result
    	}

    	function getNextSibling(vnodes, i, nextSibling) {
    		for (; i < vnodes.length; i++) {
    			if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
    		}
    		return nextSibling
    	}

    	// This covers a really specific edge case:
    	// - Parent node is keyed and contains child
    	// - Child is removed, returns unresolved promise in `onbeforeremove`
    	// - Parent node is moved in keyed diff
    	// - Remaining children still need moved appropriately
    	//
    	// Ideally, I'd track removed nodes as well, but that introduces a lot more
    	// complexity and I'm not exactly interested in doing that.
    	function moveNodes(parent, vnode, nextSibling) {
    		var frag = $doc.createDocumentFragment();
    		moveChildToFrag(parent, frag, vnode);
    		insertNode(parent, frag, nextSibling);
    	}
    	function moveChildToFrag(parent, frag, vnode) {
    		// Dodge the recursion overhead in a few of the most common cases.
    		while (vnode.dom != null && vnode.dom.parentNode === parent) {
    			if (typeof vnode.tag !== "string") {
    				vnode = vnode.instance;
    				if (vnode != null) continue
    			} else if (vnode.tag === "<") {
    				for (var i = 0; i < vnode.instance.length; i++) {
    					frag.appendChild(vnode.instance[i]);
    				}
    			} else if (vnode.tag !== "[") {
    				// Don't recurse for text nodes *or* elements, just fragments
    				frag.appendChild(vnode.dom);
    			} else if (vnode.children.length === 1) {
    				vnode = vnode.children[0];
    				if (vnode != null) continue
    			} else {
    				for (var i = 0; i < vnode.children.length; i++) {
    					var child = vnode.children[i];
    					if (child != null) moveChildToFrag(parent, frag, child);
    				}
    			}
    			break
    		}
    	}

    	function insertNode(parent, dom, nextSibling) {
    		if (nextSibling != null) parent.insertBefore(dom, nextSibling);
    		else parent.appendChild(dom);
    	}

    	function maybeSetContentEditable(vnode) {
    		if (vnode.attrs == null || (
    			vnode.attrs.contenteditable == null && // attribute
    			vnode.attrs.contentEditable == null // property
    		)) return false
    		var children = vnode.children;
    		if (children != null && children.length === 1 && children[0].tag === "<") {
    			var content = children[0].children;
    			if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content;
    		}
    		else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")
    		return true
    	}

    	//remove
    	function removeNodes(parent, vnodes, start, end) {
    		for (var i = start; i < end; i++) {
    			var vnode = vnodes[i];
    			if (vnode != null) removeNode(parent, vnode);
    		}
    	}
    	function removeNode(parent, vnode) {
    		var mask = 0;
    		var original = vnode.state;
    		var stateResult, attrsResult;
    		if (typeof vnode.tag !== "string" && typeof vnode.state.onbeforeremove === "function") {
    			var result = callHook.call(vnode.state.onbeforeremove, vnode);
    			if (result != null && typeof result.then === "function") {
    				mask = 1;
    				stateResult = result;
    			}
    		}
    		if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
    			var result = callHook.call(vnode.attrs.onbeforeremove, vnode);
    			if (result != null && typeof result.then === "function") {
    				// eslint-disable-next-line no-bitwise
    				mask |= 2;
    				attrsResult = result;
    			}
    		}
    		checkState(vnode, original);

    		// If we can, try to fast-path it and avoid all the overhead of awaiting
    		if (!mask) {
    			onremove(vnode);
    			removeChild(parent, vnode);
    		} else {
    			if (stateResult != null) {
    				var next = function () {
    					// eslint-disable-next-line no-bitwise
    					if (mask & 1) { mask &= 2; if (!mask) reallyRemove(); }
    				};
    				stateResult.then(next, next);
    			}
    			if (attrsResult != null) {
    				var next = function () {
    					// eslint-disable-next-line no-bitwise
    					if (mask & 2) { mask &= 1; if (!mask) reallyRemove(); }
    				};
    				attrsResult.then(next, next);
    			}
    		}

    		function reallyRemove() {
    			checkState(vnode, original);
    			onremove(vnode);
    			removeChild(parent, vnode);
    		}
    	}
    	function removeHTML(parent, vnode) {
    		for (var i = 0; i < vnode.instance.length; i++) {
    			parent.removeChild(vnode.instance[i]);
    		}
    	}
    	function removeChild(parent, vnode) {
    		// Dodge the recursion overhead in a few of the most common cases.
    		while (vnode.dom != null && vnode.dom.parentNode === parent) {
    			if (typeof vnode.tag !== "string") {
    				vnode = vnode.instance;
    				if (vnode != null) continue
    			} else if (vnode.tag === "<") {
    				removeHTML(parent, vnode);
    			} else {
    				if (vnode.tag !== "[") {
    					parent.removeChild(vnode.dom);
    					if (!Array.isArray(vnode.children)) break
    				}
    				if (vnode.children.length === 1) {
    					vnode = vnode.children[0];
    					if (vnode != null) continue
    				} else {
    					for (var i = 0; i < vnode.children.length; i++) {
    						var child = vnode.children[i];
    						if (child != null) removeChild(parent, child);
    					}
    				}
    			}
    			break
    		}
    	}
    	function onremove(vnode) {
    		if (typeof vnode.tag !== "string" && typeof vnode.state.onremove === "function") callHook.call(vnode.state.onremove, vnode);
    		if (vnode.attrs && typeof vnode.attrs.onremove === "function") callHook.call(vnode.attrs.onremove, vnode);
    		if (typeof vnode.tag !== "string") {
    			if (vnode.instance != null) onremove(vnode.instance);
    		} else {
    			var children = vnode.children;
    			if (Array.isArray(children)) {
    				for (var i = 0; i < children.length; i++) {
    					var child = children[i];
    					if (child != null) onremove(child);
    				}
    			}
    		}
    	}

    	//attrs
    	function setAttrs(vnode, attrs, ns) {
    		for (var key in attrs) {
    			setAttr(vnode, key, null, attrs[key], ns);
    		}
    	}
    	function setAttr(vnode, key, old, value, ns) {
    		if (key === "key" || key === "is" || value == null || isLifecycleMethod(key) || (old === value && !isFormAttribute(vnode, key)) && typeof value !== "object") return
    		if (key[0] === "o" && key[1] === "n") return updateEvent(vnode, key, value)
    		if (key.slice(0, 6) === "xlink:") vnode.dom.setAttributeNS("http://www.w3.org/1999/xlink", key.slice(6), value);
    		else if (key === "style") updateStyle(vnode.dom, old, value);
    		else if (hasPropertyKey(vnode, key, ns)) {
    			if (key === "value") {
    				// Only do the coercion if we're actually going to check the value.
    				/* eslint-disable no-implicit-coercion */
    				//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
    				if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === "" + value && vnode.dom === activeElement()) return
    				//setting select[value] to same value while having select open blinks select dropdown in Chrome
    				if (vnode.tag === "select" && old !== null && vnode.dom.value === "" + value) return
    				//setting option[value] to same value while having select open blinks select dropdown in Chrome
    				if (vnode.tag === "option" && old !== null && vnode.dom.value === "" + value) return
    				/* eslint-enable no-implicit-coercion */
    			}
    			// If you assign an input type that is not supported by IE 11 with an assignment expression, an error will occur.
    			if (vnode.tag === "input" && key === "type") vnode.dom.setAttribute(key, value);
    			else vnode.dom[key] = value;
    		} else {
    			if (typeof value === "boolean") {
    				if (value) vnode.dom.setAttribute(key, "");
    				else vnode.dom.removeAttribute(key);
    			}
    			else vnode.dom.setAttribute(key === "className" ? "class" : key, value);
    		}
    	}
    	function removeAttr(vnode, key, old, ns) {
    		if (key === "key" || key === "is" || old == null || isLifecycleMethod(key)) return
    		if (key[0] === "o" && key[1] === "n" && !isLifecycleMethod(key)) updateEvent(vnode, key, undefined);
    		else if (key === "style") updateStyle(vnode.dom, old, null);
    		else if (
    			hasPropertyKey(vnode, key, ns)
    			&& key !== "className"
    			&& !(key === "value" && (
    				vnode.tag === "option"
    				|| vnode.tag === "select" && vnode.dom.selectedIndex === -1 && vnode.dom === activeElement()
    			))
    			&& !(vnode.tag === "input" && key === "type")
    		) {
    			vnode.dom[key] = null;
    		} else {
    			var nsLastIndex = key.indexOf(":");
    			if (nsLastIndex !== -1) key = key.slice(nsLastIndex + 1);
    			if (old !== false) vnode.dom.removeAttribute(key === "className" ? "class" : key);
    		}
    	}
    	function setLateSelectAttrs(vnode, attrs) {
    		if ("value" in attrs) {
    			if(attrs.value === null) {
    				if (vnode.dom.selectedIndex !== -1) vnode.dom.value = null;
    			} else {
    				var normalized = "" + attrs.value; // eslint-disable-line no-implicit-coercion
    				if (vnode.dom.value !== normalized || vnode.dom.selectedIndex === -1) {
    					vnode.dom.value = normalized;
    				}
    			}
    		}
    		if ("selectedIndex" in attrs) setAttr(vnode, "selectedIndex", null, attrs.selectedIndex, undefined);
    	}
    	function updateAttrs(vnode, old, attrs, ns) {
    		if (attrs != null) {
    			for (var key in attrs) {
    				setAttr(vnode, key, old && old[key], attrs[key], ns);
    			}
    		}
    		var val;
    		if (old != null) {
    			for (var key in old) {
    				if (((val = old[key]) != null) && (attrs == null || attrs[key] == null)) {
    					removeAttr(vnode, key, val, ns);
    				}
    			}
    		}
    	}
    	function isFormAttribute(vnode, attr) {
    		return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === activeElement() || vnode.tag === "option" && vnode.dom.parentNode === $doc.activeElement
    	}
    	function isLifecycleMethod(attr) {
    		return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
    	}
    	function hasPropertyKey(vnode, key, ns) {
    		// Filter out namespaced keys
    		return ns === undefined && (
    			// If it's a custom element, just keep it.
    			vnode.tag.indexOf("-") > -1 || vnode.attrs != null && vnode.attrs.is ||
    			// If it's a normal element, let's try to avoid a few browser bugs.
    			key !== "href" && key !== "list" && key !== "form" && key !== "width" && key !== "height"// && key !== "type"
    			// Defer the property check until *after* we check everything.
    		) && key in vnode.dom
    	}

    	//style
    	var uppercaseRegex = /[A-Z]/g;
    	function toLowerCase(capital) { return "-" + capital.toLowerCase() }
    	function normalizeKey(key) {
    		return key[0] === "-" && key[1] === "-" ? key :
    			key === "cssFloat" ? "float" :
    				key.replace(uppercaseRegex, toLowerCase)
    	}
    	function updateStyle(element, old, style) {
    		if (old === style) ; else if (style == null) {
    			// New style is missing, just clear it.
    			element.style.cssText = "";
    		} else if (typeof style !== "object") {
    			// New style is a string, let engine deal with patching.
    			element.style.cssText = style;
    		} else if (old == null || typeof old !== "object") {
    			// `old` is missing or a string, `style` is an object.
    			element.style.cssText = "";
    			// Add new style properties
    			for (var key in style) {
    				var value = style[key];
    				if (value != null) element.style.setProperty(normalizeKey(key), String(value));
    			}
    		} else {
    			// Both old & new are (different) objects.
    			// Update style properties that have changed
    			for (var key in style) {
    				var value = style[key];
    				if (value != null && (value = String(value)) !== String(old[key])) {
    					element.style.setProperty(normalizeKey(key), value);
    				}
    			}
    			// Remove style properties that no longer exist
    			for (var key in old) {
    				if (old[key] != null && style[key] == null) {
    					element.style.removeProperty(normalizeKey(key));
    				}
    			}
    		}
    	}

    	// Here's an explanation of how this works:
    	// 1. The event names are always (by design) prefixed by `on`.
    	// 2. The EventListener interface accepts either a function or an object
    	//    with a `handleEvent` method.
    	// 3. The object does not inherit from `Object.prototype`, to avoid
    	//    any potential interference with that (e.g. setters).
    	// 4. The event name is remapped to the handler before calling it.
    	// 5. In function-based event handlers, `ev.target === this`. We replicate
    	//    that below.
    	// 6. In function-based event handlers, `return false` prevents the default
    	//    action and stops event propagation. We replicate that below.
    	function EventDict() {
    		// Save this, so the current redraw is correctly tracked.
    		this._ = currentRedraw;
    	}
    	EventDict.prototype = Object.create(null);
    	EventDict.prototype.handleEvent = function (ev) {
    		var handler = this["on" + ev.type];
    		var result;
    		if (typeof handler === "function") result = handler.call(ev.currentTarget, ev);
    		else if (typeof handler.handleEvent === "function") handler.handleEvent(ev);
    		if (this._ && ev.redraw !== false) (0, this._)();
    		if (result === false) {
    			ev.preventDefault();
    			ev.stopPropagation();
    		}
    	};

    	//event
    	function updateEvent(vnode, key, value) {
    		if (vnode.events != null) {
    			if (vnode.events[key] === value) return
    			if (value != null && (typeof value === "function" || typeof value === "object")) {
    				if (vnode.events[key] == null) vnode.dom.addEventListener(key.slice(2), vnode.events, false);
    				vnode.events[key] = value;
    			} else {
    				if (vnode.events[key] != null) vnode.dom.removeEventListener(key.slice(2), vnode.events, false);
    				vnode.events[key] = undefined;
    			}
    		} else if (value != null && (typeof value === "function" || typeof value === "object")) {
    			vnode.events = new EventDict();
    			vnode.dom.addEventListener(key.slice(2), vnode.events, false);
    			vnode.events[key] = value;
    		}
    	}

    	//lifecycle
    	function initLifecycle(source, vnode, hooks) {
    		if (typeof source.oninit === "function") callHook.call(source.oninit, vnode);
    		if (typeof source.oncreate === "function") hooks.push(callHook.bind(source.oncreate, vnode));
    	}
    	function updateLifecycle(source, vnode, hooks) {
    		if (typeof source.onupdate === "function") hooks.push(callHook.bind(source.onupdate, vnode));
    	}
    	function shouldNotUpdate(vnode, old) {
    		do {
    			if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") {
    				var force = callHook.call(vnode.attrs.onbeforeupdate, vnode, old);
    				if (force !== undefined && !force) break
    			}
    			if (typeof vnode.tag !== "string" && typeof vnode.state.onbeforeupdate === "function") {
    				var force = callHook.call(vnode.state.onbeforeupdate, vnode, old);
    				if (force !== undefined && !force) break
    			}
    			return false
    		} while (false); // eslint-disable-line no-constant-condition
    		vnode.dom = old.dom;
    		vnode.domSize = old.domSize;
    		vnode.instance = old.instance;
    		// One would think having the actual latest attributes would be ideal,
    		// but it doesn't let us properly diff based on our current internal
    		// representation. We have to save not only the old DOM info, but also
    		// the attributes used to create it, as we diff *that*, not against the
    		// DOM directly (with a few exceptions in `setAttr`). And, of course, we
    		// need to save the children and text as they are conceptually not
    		// unlike special "attributes" internally.
    		vnode.attrs = old.attrs;
    		vnode.children = old.children;
    		vnode.text = old.text;
    		return true
    	}

    	return function(dom, vnodes, redraw) {
    		if (!dom) throw new TypeError("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")
    		var hooks = [];
    		var active = activeElement();
    		var namespace = dom.namespaceURI;

    		// First time rendering into a node clears it out
    		if (dom.vnodes == null) dom.textContent = "";

    		vnodes = Vnode$2.normalizeChildren(Array.isArray(vnodes) ? vnodes : [vnodes]);
    		var prevRedraw = currentRedraw;
    		try {
    			currentRedraw = typeof redraw === "function" ? redraw : undefined;
    			updateNodes(dom, dom.vnodes, vnodes, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace);
    		} finally {
    			currentRedraw = prevRedraw;
    		}
    		dom.vnodes = vnodes;
    		// `document.activeElement` can return null: https://html.spec.whatwg.org/multipage/interaction.html#dom-document-activeelement
    		if (active != null && activeElement() !== active && typeof active.focus === "function") active.focus();
    		for (var i = 0; i < hooks.length; i++) hooks[i]();
    	}
    };

    var render$1 = render$2(window);

    var Vnode$1 = vnode;

    var mountRedraw$4 = function(render, schedule, console) {
    	var subscriptions = [];
    	var rendering = false;
    	var pending = false;

    	function sync() {
    		if (rendering) throw new Error("Nested m.redraw.sync() call")
    		rendering = true;
    		for (var i = 0; i < subscriptions.length; i += 2) {
    			try { render(subscriptions[i], Vnode$1(subscriptions[i + 1]), redraw); }
    			catch (e) { console.error(e); }
    		}
    		rendering = false;
    	}

    	function redraw() {
    		if (!pending) {
    			pending = true;
    			schedule(function() {
    				pending = false;
    				sync();
    			});
    		}
    	}

    	redraw.sync = sync;

    	function mount(root, component) {
    		if (component != null && component.view == null && typeof component !== "function") {
    			throw new TypeError("m.mount(element, component) expects a component, not a vnode")
    		}

    		var index = subscriptions.indexOf(root);
    		if (index >= 0) {
    			subscriptions.splice(index, 2);
    			render(root, [], redraw);
    		}

    		if (component != null) {
    			subscriptions.push(root, component);
    			render(root, Vnode$1(component), redraw);
    		}
    	}

    	return {mount: mount, redraw: redraw}
    };

    var render = render$1;

    var mountRedraw$3 = mountRedraw$4(render, requestAnimationFrame, console);

    var build$1 = function(object) {
    	if (Object.prototype.toString.call(object) !== "[object Object]") return ""

    	var args = [];
    	for (var key in object) {
    		destructure(key, object[key]);
    	}

    	return args.join("&")

    	function destructure(key, value) {
    		if (Array.isArray(value)) {
    			for (var i = 0; i < value.length; i++) {
    				destructure(key + "[" + i + "]", value[i]);
    			}
    		}
    		else if (Object.prototype.toString.call(value) === "[object Object]") {
    			for (var i in value) {
    				destructure(key + "[" + i + "]", value[i]);
    			}
    		}
    		else args.push(encodeURIComponent(key) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""));
    	}
    };

    var assign$2 = Object.assign || function(target, source) {
    	if(source) Object.keys(source).forEach(function(key) { target[key] = source[key]; });
    };

    var buildQueryString = build$1;
    var assign$1 = assign$2;

    // Returns `path` from `template` + `params`
    var build = function(template, params) {
    	if ((/:([^\/\.-]+)(\.{3})?:/).test(template)) {
    		throw new SyntaxError("Template parameter names *must* be separated")
    	}
    	if (params == null) return template
    	var queryIndex = template.indexOf("?");
    	var hashIndex = template.indexOf("#");
    	var queryEnd = hashIndex < 0 ? template.length : hashIndex;
    	var pathEnd = queryIndex < 0 ? queryEnd : queryIndex;
    	var path = template.slice(0, pathEnd);
    	var query = {};

    	assign$1(query, params);

    	var resolved = path.replace(/:([^\/\.-]+)(\.{3})?/g, function(m, key, variadic) {
    		delete query[key];
    		// If no such parameter exists, don't interpolate it.
    		if (params[key] == null) return m
    		// Escape normal parameters, but not variadic ones.
    		return variadic ? params[key] : encodeURIComponent(String(params[key]))
    	});

    	// In case the template substitution adds new query/hash parameters.
    	var newQueryIndex = resolved.indexOf("?");
    	var newHashIndex = resolved.indexOf("#");
    	var newQueryEnd = newHashIndex < 0 ? resolved.length : newHashIndex;
    	var newPathEnd = newQueryIndex < 0 ? newQueryEnd : newQueryIndex;
    	var result = resolved.slice(0, newPathEnd);

    	if (queryIndex >= 0) result += template.slice(queryIndex, queryEnd);
    	if (newQueryIndex >= 0) result += (queryIndex < 0 ? "?" : "&") + resolved.slice(newQueryIndex, newQueryEnd);
    	var querystring = buildQueryString(query);
    	if (querystring) result += (queryIndex < 0 && newQueryIndex < 0 ? "?" : "&") + querystring;
    	if (hashIndex >= 0) result += template.slice(hashIndex);
    	if (newHashIndex >= 0) result += (hashIndex < 0 ? "" : "&") + resolved.slice(newHashIndex);
    	return result
    };

    var buildPathname$1 = build;

    var request$2 = function($window, Promise, oncompletion) {
    	var callbackCount = 0;

    	function PromiseProxy(executor) {
    		return new Promise(executor)
    	}

    	// In case the global Promise is some userland library's where they rely on
    	// `foo instanceof this.constructor`, `this.constructor.resolve(value)`, or
    	// similar. Let's *not* break them.
    	PromiseProxy.prototype = Promise.prototype;
    	PromiseProxy.__proto__ = Promise; // eslint-disable-line no-proto

    	function makeRequest(factory) {
    		return function(url, args) {
    			if (typeof url !== "string") { args = url; url = url.url; }
    			else if (args == null) args = {};
    			var promise = new Promise(function(resolve, reject) {
    				factory(buildPathname$1(url, args.params), args, function (data) {
    					if (typeof args.type === "function") {
    						if (Array.isArray(data)) {
    							for (var i = 0; i < data.length; i++) {
    								data[i] = new args.type(data[i]);
    							}
    						}
    						else data = new args.type(data);
    					}
    					resolve(data);
    				}, reject);
    			});
    			if (args.background === true) return promise
    			var count = 0;
    			function complete() {
    				if (--count === 0 && typeof oncompletion === "function") oncompletion();
    			}

    			return wrap(promise)

    			function wrap(promise) {
    				var then = promise.then;
    				// Set the constructor, so engines know to not await or resolve
    				// this as a native promise. At the time of writing, this is
    				// only necessary for V8, but their behavior is the correct
    				// behavior per spec. See this spec issue for more details:
    				// https://github.com/tc39/ecma262/issues/1577. Also, see the
    				// corresponding comment in `request/tests/test-request.js` for
    				// a bit more background on the issue at hand.
    				promise.constructor = PromiseProxy;
    				promise.then = function() {
    					count++;
    					var next = then.apply(promise, arguments);
    					next.then(complete, function(e) {
    						complete();
    						if (count === 0) throw e
    					});
    					return wrap(next)
    				};
    				return promise
    			}
    		}
    	}

    	function hasHeader(args, name) {
    		for (var key in args.headers) {
    			if ({}.hasOwnProperty.call(args.headers, key) && name.test(key)) return true
    		}
    		return false
    	}

    	return {
    		request: makeRequest(function(url, args, resolve, reject) {
    			var method = args.method != null ? args.method.toUpperCase() : "GET";
    			var body = args.body;
    			var assumeJSON = (args.serialize == null || args.serialize === JSON.serialize) && !(body instanceof $window.FormData);
    			var responseType = args.responseType || (typeof args.extract === "function" ? "" : "json");

    			var xhr = new $window.XMLHttpRequest(), aborted = false;
    			var original = xhr, replacedAbort;
    			var abort = xhr.abort;

    			xhr.abort = function() {
    				aborted = true;
    				abort.call(this);
    			};

    			xhr.open(method, url, args.async !== false, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined);

    			if (assumeJSON && body != null && !hasHeader(args, /^content-type$/i)) {
    				xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8");
    			}
    			if (typeof args.deserialize !== "function" && !hasHeader(args, /^accept$/i)) {
    				xhr.setRequestHeader("Accept", "application/json, text/*");
    			}
    			if (args.withCredentials) xhr.withCredentials = args.withCredentials;
    			if (args.timeout) xhr.timeout = args.timeout;
    			xhr.responseType = responseType;

    			for (var key in args.headers) {
    				if ({}.hasOwnProperty.call(args.headers, key)) {
    					xhr.setRequestHeader(key, args.headers[key]);
    				}
    			}

    			xhr.onreadystatechange = function(ev) {
    				// Don't throw errors on xhr.abort().
    				if (aborted) return

    				if (ev.target.readyState === 4) {
    					try {
    						var success = (ev.target.status >= 200 && ev.target.status < 300) || ev.target.status === 304 || (/^file:\/\//i).test(url);
    						// When the response type isn't "" or "text",
    						// `xhr.responseText` is the wrong thing to use.
    						// Browsers do the right thing and throw here, and we
    						// should honor that and do the right thing by
    						// preferring `xhr.response` where possible/practical.
    						var response = ev.target.response, message;

    						if (responseType === "json") {
    							// For IE and Edge, which don't implement
    							// `responseType: "json"`.
    							if (!ev.target.responseType && typeof args.extract !== "function") response = JSON.parse(ev.target.responseText);
    						} else if (!responseType || responseType === "text") {
    							// Only use this default if it's text. If a parsed
    							// document is needed on old IE and friends (all
    							// unsupported), the user should use a custom
    							// `config` instead. They're already using this at
    							// their own risk.
    							if (response == null) response = ev.target.responseText;
    						}

    						if (typeof args.extract === "function") {
    							response = args.extract(ev.target, args);
    							success = true;
    						} else if (typeof args.deserialize === "function") {
    							response = args.deserialize(response);
    						}
    						if (success) resolve(response);
    						else {
    							try { message = ev.target.responseText; }
    							catch (e) { message = response; }
    							var error = new Error(message);
    							error.code = ev.target.status;
    							error.response = response;
    							reject(error);
    						}
    					}
    					catch (e) {
    						reject(e);
    					}
    				}
    			};

    			if (typeof args.config === "function") {
    				xhr = args.config(xhr, args, url) || xhr;

    				// Propagate the `abort` to any replacement XHR as well.
    				if (xhr !== original) {
    					replacedAbort = xhr.abort;
    					xhr.abort = function() {
    						aborted = true;
    						replacedAbort.call(this);
    					};
    				}
    			}

    			if (body == null) xhr.send();
    			else if (typeof args.serialize === "function") xhr.send(args.serialize(body));
    			else if (body instanceof $window.FormData) xhr.send(body);
    			else xhr.send(JSON.stringify(body));
    		}),
    		jsonp: makeRequest(function(url, args, resolve, reject) {
    			var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++;
    			var script = $window.document.createElement("script");
    			$window[callbackName] = function(data) {
    				delete $window[callbackName];
    				script.parentNode.removeChild(script);
    				resolve(data);
    			};
    			script.onerror = function() {
    				delete $window[callbackName];
    				script.parentNode.removeChild(script);
    				reject(new Error("JSONP request failed"));
    			};
    			script.src = url + (url.indexOf("?") < 0 ? "?" : "&") +
    				encodeURIComponent(args.callbackKey || "callback") + "=" +
    				encodeURIComponent(callbackName);
    			$window.document.documentElement.appendChild(script);
    		}),
    	}
    };

    var PromisePolyfill = promise.exports;
    var mountRedraw$2 = mountRedraw$3;

    var request$1 = request$2(window, PromisePolyfill, mountRedraw$2.redraw);

    var parse$1 = function(string) {
    	if (string === "" || string == null) return {}
    	if (string.charAt(0) === "?") string = string.slice(1);

    	var entries = string.split("&"), counters = {}, data = {};
    	for (var i = 0; i < entries.length; i++) {
    		var entry = entries[i].split("=");
    		var key = decodeURIComponent(entry[0]);
    		var value = entry.length === 2 ? decodeURIComponent(entry[1]) : "";

    		if (value === "true") value = true;
    		else if (value === "false") value = false;

    		var levels = key.split(/\]\[?|\[/);
    		var cursor = data;
    		if (key.indexOf("[") > -1) levels.pop();
    		for (var j = 0; j < levels.length; j++) {
    			var level = levels[j], nextLevel = levels[j + 1];
    			var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10));
    			if (level === "") {
    				var key = levels.slice(0, j).join();
    				if (counters[key] == null) {
    					counters[key] = Array.isArray(cursor) ? cursor.length : 0;
    				}
    				level = counters[key]++;
    			}
    			// Disallow direct prototype pollution
    			else if (level === "__proto__") break
    			if (j === levels.length - 1) cursor[level] = value;
    			else {
    				// Read own properties exclusively to disallow indirect
    				// prototype pollution
    				var desc = Object.getOwnPropertyDescriptor(cursor, level);
    				if (desc != null) desc = desc.value;
    				if (desc == null) cursor[level] = desc = isNumber ? [] : {};
    				cursor = desc;
    			}
    		}
    	}
    	return data
    };

    var parseQueryString = parse$1;

    // Returns `{path, params}` from `url`
    var parse = function(url) {
    	var queryIndex = url.indexOf("?");
    	var hashIndex = url.indexOf("#");
    	var queryEnd = hashIndex < 0 ? url.length : hashIndex;
    	var pathEnd = queryIndex < 0 ? queryEnd : queryIndex;
    	var path = url.slice(0, pathEnd).replace(/\/{2,}/g, "/");

    	if (!path) path = "/";
    	else {
    		if (path[0] !== "/") path = "/" + path;
    		if (path.length > 1 && path[path.length - 1] === "/") path = path.slice(0, -1);
    	}
    	return {
    		path: path,
    		params: queryIndex < 0
    			? {}
    			: parseQueryString(url.slice(queryIndex + 1, queryEnd)),
    	}
    };

    var parsePathname$1 = parse;

    // Compiles a template into a function that takes a resolved path (without query
    // strings) and returns an object containing the template parameters with their
    // parsed values. This expects the input of the compiled template to be the
    // output of `parsePathname`. Note that it does *not* remove query parameters
    // specified in the template.
    var compileTemplate$1 = function(template) {
    	var templateData = parsePathname$1(template);
    	var templateKeys = Object.keys(templateData.params);
    	var keys = [];
    	var regexp = new RegExp("^" + templateData.path.replace(
    		// I escape literal text so people can use things like `:file.:ext` or
    		// `:lang-:locale` in routes. This is all merged into one pass so I
    		// don't also accidentally escape `-` and make it harder to detect it to
    		// ban it from template parameters.
    		/:([^\/.-]+)(\.{3}|\.(?!\.)|-)?|[\\^$*+.()|\[\]{}]/g,
    		function(m, key, extra) {
    			if (key == null) return "\\" + m
    			keys.push({k: key, r: extra === "..."});
    			if (extra === "...") return "(.*)"
    			if (extra === ".") return "([^/]+)\\."
    			return "([^/]+)" + (extra || "")
    		}
    	) + "$");
    	return function(data) {
    		// First, check the params. Usually, there isn't any, and it's just
    		// checking a static set.
    		for (var i = 0; i < templateKeys.length; i++) {
    			if (templateData.params[templateKeys[i]] !== data.params[templateKeys[i]]) return false
    		}
    		// If no interpolations exist, let's skip all the ceremony
    		if (!keys.length) return regexp.test(data.path)
    		var values = regexp.exec(data.path);
    		if (values == null) return false
    		for (var i = 0; i < keys.length; i++) {
    			data.params[keys[i].k] = keys[i].r ? values[i + 1] : decodeURIComponent(values[i + 1]);
    		}
    		return true
    	}
    };

    var Vnode = vnode;
    var m$1 = hyperscript_1$1;
    var Promise$1 = promise.exports;

    var buildPathname = build;
    var parsePathname = parse;
    var compileTemplate = compileTemplate$1;
    var assign = assign$2;

    var sentinel = {};

    var router = function($window, mountRedraw) {
    	var fireAsync;

    	function setPath(path, data, options) {
    		path = buildPathname(path, data);
    		if (fireAsync != null) {
    			fireAsync();
    			var state = options ? options.state : null;
    			var title = options ? options.title : null;
    			if (options && options.replace) $window.history.replaceState(state, title, route.prefix + path);
    			else $window.history.pushState(state, title, route.prefix + path);
    		}
    		else {
    			$window.location.href = route.prefix + path;
    		}
    	}

    	var currentResolver = sentinel, component, attrs, currentPath, lastUpdate;

    	var SKIP = route.SKIP = {};

    	function route(root, defaultRoute, routes) {
    		if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")
    		// 0 = start
    		// 1 = init
    		// 2 = ready
    		var state = 0;

    		var compiled = Object.keys(routes).map(function(route) {
    			if (route[0] !== "/") throw new SyntaxError("Routes must start with a `/`")
    			if ((/:([^\/\.-]+)(\.{3})?:/).test(route)) {
    				throw new SyntaxError("Route parameter names must be separated with either `/`, `.`, or `-`")
    			}
    			return {
    				route: route,
    				component: routes[route],
    				check: compileTemplate(route),
    			}
    		});
    		var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout;
    		var p = Promise$1.resolve();
    		var scheduled = false;
    		var onremove;

    		fireAsync = null;

    		if (defaultRoute != null) {
    			var defaultData = parsePathname(defaultRoute);

    			if (!compiled.some(function (i) { return i.check(defaultData) })) {
    				throw new ReferenceError("Default route doesn't match any known routes")
    			}
    		}

    		function resolveRoute() {
    			scheduled = false;
    			// Consider the pathname holistically. The prefix might even be invalid,
    			// but that's not our problem.
    			var prefix = $window.location.hash;
    			if (route.prefix[0] !== "#") {
    				prefix = $window.location.search + prefix;
    				if (route.prefix[0] !== "?") {
    					prefix = $window.location.pathname + prefix;
    					if (prefix[0] !== "/") prefix = "/" + prefix;
    				}
    			}
    			// This seemingly useless `.concat()` speeds up the tests quite a bit,
    			// since the representation is consistently a relatively poorly
    			// optimized cons string.
    			var path = prefix.concat()
    				.replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)
    				.slice(route.prefix.length);
    			var data = parsePathname(path);

    			assign(data.params, $window.history.state);

    			function fail() {
    				if (path === defaultRoute) throw new Error("Could not resolve default route " + defaultRoute)
    				setPath(defaultRoute, null, {replace: true});
    			}

    			loop(0);
    			function loop(i) {
    				// 0 = init
    				// 1 = scheduled
    				// 2 = done
    				for (; i < compiled.length; i++) {
    					if (compiled[i].check(data)) {
    						var payload = compiled[i].component;
    						var matchedRoute = compiled[i].route;
    						var localComp = payload;
    						var update = lastUpdate = function(comp) {
    							if (update !== lastUpdate) return
    							if (comp === SKIP) return loop(i + 1)
    							component = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div";
    							attrs = data.params, currentPath = path, lastUpdate = null;
    							currentResolver = payload.render ? payload : null;
    							if (state === 2) mountRedraw.redraw();
    							else {
    								state = 2;
    								mountRedraw.redraw.sync();
    							}
    						};
    						// There's no understating how much I *wish* I could
    						// use `async`/`await` here...
    						if (payload.view || typeof payload === "function") {
    							payload = {};
    							update(localComp);
    						}
    						else if (payload.onmatch) {
    							p.then(function () {
    								return payload.onmatch(data.params, path, matchedRoute)
    							}).then(update, fail);
    						}
    						else update("div");
    						return
    					}
    				}
    				fail();
    			}
    		}

    		// Set it unconditionally so `m.route.set` and `m.route.Link` both work,
    		// even if neither `pushState` nor `hashchange` are supported. It's
    		// cleared if `hashchange` is used, since that makes it automatically
    		// async.
    		fireAsync = function() {
    			if (!scheduled) {
    				scheduled = true;
    				callAsync(resolveRoute);
    			}
    		};

    		if (typeof $window.history.pushState === "function") {
    			onremove = function() {
    				$window.removeEventListener("popstate", fireAsync, false);
    			};
    			$window.addEventListener("popstate", fireAsync, false);
    		} else if (route.prefix[0] === "#") {
    			fireAsync = null;
    			onremove = function() {
    				$window.removeEventListener("hashchange", resolveRoute, false);
    			};
    			$window.addEventListener("hashchange", resolveRoute, false);
    		}

    		return mountRedraw.mount(root, {
    			onbeforeupdate: function() {
    				state = state ? 2 : 1;
    				return !(!state || sentinel === currentResolver)
    			},
    			oncreate: resolveRoute,
    			onremove: onremove,
    			view: function() {
    				if (!state || sentinel === currentResolver) return
    				// Wrap in a fragment to preserve existing key semantics
    				var vnode = [Vnode(component, attrs.key, attrs)];
    				if (currentResolver) vnode = currentResolver.render(vnode[0]);
    				return vnode
    			},
    		})
    	}
    	route.set = function(path, data, options) {
    		if (lastUpdate != null) {
    			options = options || {};
    			options.replace = true;
    		}
    		lastUpdate = null;
    		setPath(path, data, options);
    	};
    	route.get = function() {return currentPath};
    	route.prefix = "#!";
    	route.Link = {
    		view: function(vnode) {
    			var options = vnode.attrs.options;
    			// Remove these so they don't get overwritten
    			var attrs = {}, onclick, href;
    			assign(attrs, vnode.attrs);
    			// The first two are internal, but the rest are magic attributes
    			// that need censored to not screw up rendering.
    			attrs.selector = attrs.options = attrs.key = attrs.oninit =
    			attrs.oncreate = attrs.onbeforeupdate = attrs.onupdate =
    			attrs.onbeforeremove = attrs.onremove = null;

    			// Do this now so we can get the most current `href` and `disabled`.
    			// Those attributes may also be specified in the selector, and we
    			// should honor that.
    			var child = m$1(vnode.attrs.selector || "a", attrs, vnode.children);

    			// Let's provide a *right* way to disable a route link, rather than
    			// letting people screw up accessibility on accident.
    			//
    			// The attribute is coerced so users don't get surprised over
    			// `disabled: 0` resulting in a button that's somehow routable
    			// despite being visibly disabled.
    			if (child.attrs.disabled = Boolean(child.attrs.disabled)) {
    				child.attrs.href = null;
    				child.attrs["aria-disabled"] = "true";
    				// If you *really* do want to do this on a disabled link, use
    				// an `oncreate` hook to add it.
    				child.attrs.onclick = null;
    			} else {
    				onclick = child.attrs.onclick;
    				href = child.attrs.href;
    				child.attrs.href = route.prefix + href;
    				child.attrs.onclick = function(e) {
    					var result;
    					if (typeof onclick === "function") {
    						result = onclick.call(e.currentTarget, e);
    					} else if (onclick == null || typeof onclick !== "object") ; else if (typeof onclick.handleEvent === "function") {
    						onclick.handleEvent(e);
    					}

    					// Adapted from React Router's implementation:
    					// https://github.com/ReactTraining/react-router/blob/520a0acd48ae1b066eb0b07d6d4d1790a1d02482/packages/react-router-dom/modules/Link.js
    					//
    					// Try to be flexible and intuitive in how we handle links.
    					// Fun fact: links aren't as obvious to get right as you
    					// would expect. There's a lot more valid ways to click a
    					// link than this, and one might want to not simply click a
    					// link, but right click or command-click it to copy the
    					// link target, etc. Nope, this isn't just for blind people.
    					if (
    						// Skip if `onclick` prevented default
    						result !== false && !e.defaultPrevented &&
    						// Ignore everything but left clicks
    						(e.button === 0 || e.which === 0 || e.which === 1) &&
    						// Let the browser handle `target=_blank`, etc.
    						(!e.currentTarget.target || e.currentTarget.target === "_self") &&
    						// No modifier keys
    						!e.ctrlKey && !e.metaKey && !e.shiftKey && !e.altKey
    					) {
    						e.preventDefault();
    						e.redraw = false;
    						route.set(href, null, options);
    					}
    				};
    			}
    			return child
    		},
    	};
    	route.param = function(key) {
    		return attrs && key != null ? attrs[key] : attrs
    	};

    	return route
    };

    var mountRedraw$1 = mountRedraw$3;

    var route = router(window, mountRedraw$1);

    var hyperscript = hyperscript_1;
    var request = request$1;
    var mountRedraw = mountRedraw$3;

    var m = function m() { return hyperscript.apply(this, arguments) };
    m.m = hyperscript;
    m.trust = hyperscript.trust;
    m.fragment = hyperscript.fragment;
    m.mount = mountRedraw.mount;
    m.route = route;
    m.render = render$1;
    m.redraw = mountRedraw.redraw;
    m.request = request.request;
    m.jsonp = request.jsonp;
    m.parseQueryString = parse$1;
    m.buildQueryString = build$1;
    m.parsePathname = parse;
    m.buildPathname = build;
    m.vnode = vnode;
    m.PromisePolyfill = polyfill;

    var mithril = m;

    Swiper.use([Navigation, Pagination, Scrollbar]);
    var Slider = {
        oncreate: function (vnode) {
            var state = vnode.state;
            state.slider = new Swiper('.swiper', {
                pagination: {
                    clickable: true,
                    el: '.swiper-pagination',
                    renderBullet: function (index, className) {
                        return '<span class="' + className + '">' + (index + 1) + '</span>';
                    },
                },
                navigation: {
                    nextEl: '.swiper-button-next',
                    prevEl: '.swiper-button-prev',
                },
                scrollbar: {
                    el: '.swiper-scrollbar',
                },
                longSwipes: true,
                shortSwipes: false,
                simulateTouch: false,
            });
        },
        onupdate: function (_a) {
            var _b;
            var state = _a.state;
            var slider = state.slider;
            (_b = slider.update) === null || _b === void 0 ? void 0 : _b.call(slider);
        },
        view: function (_a) {
            var attrs = _a.attrs;
            var slides = attrs.slides;
            return (mithril("div", { class: "swiper" },
                mithril("div", { class: "swiper-wrapper" }, slides.map(function (slide, index) {
                    return mithril("div", { class: "swiper-slide", key: "slide-" + index }, slide);
                })),
                mithril("div", { class: "swiper-scrollbar" }),
                mithril("div", { class: "swiper-button-prev" },
                    mithril("i", { class: "fas fa-arrow-circle-left" })),
                mithril("div", { class: "swiper-button-next" },
                    mithril("i", { class: "fas fa-arrow-circle-right" })),
                mithril("div", { class: "swiper-pagination" })));
        }
    };

    var Slide = mithril("article", { "class": "slide" }, "Slide Content");
    var Root = {
        view: function () {
            return ([
                mithril(Slider, { slides: [Slide, Slide, Slide] }),
            ]);
        },
    };
    mithril.mount(document.querySelector('.example-app'), Root);

})();
